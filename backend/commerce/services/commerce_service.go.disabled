package services

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"tchat.dev/shared/models"
	sharedModels "tchat.dev/shared/models"
)

// CommerceService provides e-commerce functionality
type CommerceService struct {
	shopRepo    ShopRepository
	productRepo ProductRepository
	orderRepo   OrderRepository
	cache       CacheService
	events      EventService
	payment     PaymentService
	config      *CommerceConfig
}

// CommerceConfig holds commerce service configuration
type CommerceConfig struct {
	MaxProductsPerShop    int
	MaxOrdersPerUser      int
	OrderExpiryTime       time.Duration
	MaxProductImages      int
	MaxProductVariants    int
	CommissionRate        float64
	AutoApproveProducts   bool
	EnableInventoryTracking bool
	MaxShopNameLength     int
	MaxProductNameLength  int
}

// DefaultCommerceConfig returns default commerce configuration
func DefaultCommerceConfig() *CommerceConfig {
	return &CommerceConfig{
		MaxProductsPerShop:     10000,
		MaxOrdersPerUser:       1000,
		OrderExpiryTime:        30 * time.Minute,
		MaxProductImages:       10,
		MaxProductVariants:     50,
		CommissionRate:         0.05, // 5%
		AutoApproveProducts:    false,
		EnableInventoryTracking: true,
		MaxShopNameLength:      100,
		MaxProductNameLength:   200,
	}
}

// Repository interfaces
type ShopRepository interface {
	Create(ctx context.Context, shop *models.Shop) error
	GetByID(ctx context.Context, id uuid.UUID) (*models.Shop, error)
	GetByOwnerID(ctx context.Context, ownerID uuid.UUID) ([]*models.Shop, error)
	GetBySlug(ctx context.Context, slug string) (*models.Shop, error)
	Update(ctx context.Context, shop *models.Shop) error
	Delete(ctx context.Context, id uuid.UUID) error
	Search(ctx context.Context, query string, limit, offset int) ([]*models.Shop, error)
	GetFeatured(ctx context.Context, limit int) ([]*models.Shop, error)
}

type ProductRepository interface {
	Create(ctx context.Context, product *models.Product) error
	GetByID(ctx context.Context, id uuid.UUID) (*models.Product, error)
	GetByShopID(ctx context.Context, shopID uuid.UUID, limit, offset int) ([]*models.Product, error)
	GetBySKU(ctx context.Context, sku string) (*models.Product, error)
	Update(ctx context.Context, product *models.Product) error
	Delete(ctx context.Context, id uuid.UUID) error
	Search(ctx context.Context, query string, filters map[string]interface{}, limit, offset int) ([]*models.Product, error)
	GetByCategory(ctx context.Context, category string, limit, offset int) ([]*models.Product, error)
	UpdateInventory(ctx context.Context, productID uuid.UUID, quantity int) error
	LockForUpdate(ctx context.Context, productID uuid.UUID) (*models.Product, error)
}

type OrderRepository interface {
	Create(ctx context.Context, order *models.Order) error
	GetByID(ctx context.Context, id uuid.UUID) (*models.Order, error)
	GetByUserID(ctx context.Context, userID uuid.UUID, limit, offset int) ([]*models.Order, error)
	GetByShopID(ctx context.Context, shopID uuid.UUID, limit, offset int) ([]*models.Order, error)
	Update(ctx context.Context, order *models.Order) error
	Delete(ctx context.Context, id uuid.UUID) error
	GetPendingOrders(ctx context.Context) ([]*models.Order, error)
	UpdateStatus(ctx context.Context, orderID uuid.UUID, status models.OrderStatus) error
}

// Service interfaces
type CacheService interface {
	Set(ctx context.Context, key string, value interface{}, expiry time.Duration) error
	Get(ctx context.Context, key string) (interface{}, error)
	Delete(ctx context.Context, key string) error
	Lock(ctx context.Context, key string, expiry time.Duration) (bool, error)
	Unlock(ctx context.Context, key string) error
}

type EventService interface {
	PublishShop(ctx context.Context, event *ShopEvent) error
	PublishProduct(ctx context.Context, event *ProductEvent) error
	PublishOrder(ctx context.Context, event *OrderEvent) error
}

type PaymentService interface {
	CreatePayment(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error)
	ProcessRefund(ctx context.Context, req *RefundRequest) (*RefundResponse, error)
	ValidatePayment(ctx context.Context, paymentID string) (*PaymentStatus, error)
}

// Event types
type ShopEvent struct {
	Type      string        `json:"type"`
	ShopID    uuid.UUID     `json:"shop_id"`
	OwnerID   uuid.UUID     `json:"owner_id"`
	Shop      *models.Shop  `json:"shop,omitempty"`
	Timestamp time.Time     `json:"timestamp"`
}

type ProductEvent struct {
	Type      string           `json:"type"`
	ProductID uuid.UUID        `json:"product_id"`
	ShopID    uuid.UUID        `json:"shop_id"`
	Product   *models.Product  `json:"product,omitempty"`
	Timestamp time.Time        `json:"timestamp"`
}

type OrderEvent struct {
	Type      string         `json:"type"`
	OrderID   uuid.UUID      `json:"order_id"`
	UserID    uuid.UUID      `json:"user_id"`
	ShopID    uuid.UUID      `json:"shop_id"`
	Order     *models.Order  `json:"order,omitempty"`
	Timestamp time.Time      `json:"timestamp"`
}

// Request/Response types
type CreateShopRequest struct {
	OwnerID     uuid.UUID `json:"owner_id"`
	Name        string    `json:"name"`
	Description *string   `json:"description,omitempty"`
	Category    string    `json:"category"`
	Logo        *string   `json:"logo,omitempty"`
	Banner      *string   `json:"banner,omitempty"`
	Address     *string   `json:"address,omitempty"`
	Phone       *string   `json:"phone,omitempty"`
	Email       *string   `json:"email,omitempty"`
	Website     *string   `json:"website,omitempty"`
}

type CreateProductRequest struct {
	ShopID      uuid.UUID                  `json:"shop_id"`
	Name        string                     `json:"name"`
	Description *string                    `json:"description,omitempty"`
	Category    string                     `json:"category"`
	Price       int64                      `json:"price"`
	Currency    models.Currency            `json:"currency"`
	Inventory   int                        `json:"inventory"`
	Images      []string                   `json:"images,omitempty"`
	Variants    []models.ProductVariant    `json:"variants,omitempty"`
	Tags        []string                   `json:"tags,omitempty"`
	Metadata    map[string]string          `json:"metadata,omitempty"`
}

type CreateOrderRequest struct {
	UserID      uuid.UUID              `json:"user_id"`
	ShopID      uuid.UUID              `json:"shop_id"`
	Items       []OrderItem            `json:"items"`
	Currency    models.Currency        `json:"currency"`
	ShippingAddress *models.Address    `json:"shipping_address,omitempty"`
	BillingAddress  *models.Address    `json:"billing_address,omitempty"`
	Notes       *string                `json:"notes,omitempty"`
}

type OrderItem struct {
	ProductID uuid.UUID `json:"product_id"`
	VariantID *uuid.UUID `json:"variant_id,omitempty"`
	Quantity  int       `json:"quantity"`
	Price     int64     `json:"price"`
}

type PaymentRequest struct {
	OrderID     uuid.UUID       `json:"order_id"`
	Amount      int64           `json:"amount"`
	Currency    models.Currency `json:"currency"`
	Method      string          `json:"method"`
	Description string          `json:"description"`
}

type PaymentResponse struct {
	PaymentID   string    `json:"payment_id"`
	Status      string    `json:"status"`
	RedirectURL *string   `json:"redirect_url,omitempty"`
	ExpiresAt   time.Time `json:"expires_at"`
}

type RefundRequest struct {
	PaymentID string  `json:"payment_id"`
	Amount    int64   `json:"amount"`
	Reason    string  `json:"reason"`
}

type RefundResponse struct {
	RefundID  string    `json:"refund_id"`
	Status    string    `json:"status"`
	ProcessedAt time.Time `json:"processed_at"`
}

type PaymentStatus struct {
	PaymentID string `json:"payment_id"`
	Status    string `json:"status"`
	Amount    int64  `json:"amount"`
	PaidAt    *time.Time `json:"paid_at,omitempty"`
}

// NewCommerceService creates a new commerce service
func NewCommerceService(
	shopRepo ShopRepository,
	productRepo ProductRepository,
	orderRepo OrderRepository,
	cache CacheService,
	events EventService,
	payment PaymentService,
	config *CommerceConfig,
) *CommerceService {
	if config == nil {
		config = DefaultCommerceConfig()
	}

	return &CommerceService{
		shopRepo:    shopRepo,
		productRepo: productRepo,
		orderRepo:   orderRepo,
		cache:       cache,
		events:      events,
		payment:     payment,
		config:      config,
	}
}

// CreateShop creates a new shop
func (c *CommerceService) CreateShop(ctx context.Context, req *CreateShopRequest) (*models.Shop, error) {
	// Validate request
	if err := c.validateCreateShopRequest(req); err != nil {
		return nil, fmt.Errorf("invalid create shop request: %v", err)
	}

	// Check if user already has a shop with the same name
	existingShops, err := c.shopRepo.GetByOwnerID(ctx, req.OwnerID)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing shops: %v", err)
	}

	for _, shop := range existingShops {
		if strings.EqualFold(shop.Name, req.Name) {
			return nil, fmt.Errorf("shop with name '%s' already exists", req.Name)
		}
	}

	// Create shop
	shop := &models.Shop{
		OwnerID:     req.OwnerID,
		Name:        req.Name,
		Description: req.Description,
		Category:    req.Category,
		Logo:        req.Logo,
		Banner:      req.Banner,
		Address:     req.Address,
		Phone:       req.Phone,
		Email:       req.Email,
		Website:     req.Website,
		Status:      models.ShopStatusActive,
		IsVerified:  false,
	}

	// Set up shop before creation
	if err := shop.BeforeCreate(); err != nil {
		return nil, fmt.Errorf("failed to prepare shop: %v", err)
	}

	// Validate shop
	if err := shop.Validate(); err != nil {
		return nil, fmt.Errorf("shop validation failed: %v", err)
	}

	// Save shop
	if err := c.shopRepo.Create(ctx, shop); err != nil {
		return nil, fmt.Errorf("failed to create shop: %v", err)
	}

	// Publish shop creation event
	event := &ShopEvent{
		Type:      "shop_created",
		ShopID:    shop.ID,
		OwnerID:   req.OwnerID,
		Shop:      shop,
		Timestamp: time.Now().UTC(),
	}
	c.events.PublishShop(ctx, event)

	return shop, nil
}

// CreateProduct creates a new product
func (c *CommerceService) CreateProduct(ctx context.Context, req *CreateProductRequest) (*models.Product, error) {
	// Validate request
	if err := c.validateCreateProductRequest(req); err != nil {
		return nil, fmt.Errorf("invalid create product request: %v", err)
	}

	// Get shop
	shop, err := c.shopRepo.GetByID(ctx, req.ShopID)
	if err != nil {
		return nil, fmt.Errorf("shop not found: %v", err)
	}

	// Check shop status
	if shop.Status != models.ShopStatusActive {
		return nil, fmt.Errorf("shop is not active")
	}

	// Check product limit
	existingProducts, err := c.productRepo.GetByShopID(ctx, req.ShopID, c.config.MaxProductsPerShop, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to check product count: %v", err)
	}

	if len(existingProducts) >= c.config.MaxProductsPerShop {
		return nil, fmt.Errorf("shop has reached maximum number of products (%d)", c.config.MaxProductsPerShop)
	}

	// Create product
	product := &models.Product{
		ShopID:      req.ShopID,
		Name:        req.Name,
		Description: req.Description,
		Category:    req.Category,
		Price:       req.Price,
		Currency:    req.Currency,
		Inventory:   req.Inventory,
		Images:      req.Images,
		Variants:    req.Variants,
		Tags:        req.Tags,
		Metadata:    req.Metadata,
	}

	// Set product status based on configuration
	if c.config.AutoApproveProducts {
		product.Status = models.ProductStatusActive
	} else {
		product.Status = models.ProductStatusPending
	}

	// Set up product before creation
	if err := product.BeforeCreate(); err != nil {
		return nil, fmt.Errorf("failed to prepare product: %v", err)
	}

	// Validate product
	if err := product.Validate(); err != nil {
		return nil, fmt.Errorf("product validation failed: %v", err)
	}

	// Save product
	if err := c.productRepo.Create(ctx, product); err != nil {
		return nil, fmt.Errorf("failed to create product: %v", err)
	}

	// Update shop product count
	shop.ProductCount++
	shop.UpdatedAt = time.Now().UTC()
	if err := c.shopRepo.Update(ctx, shop); err != nil {
		// Log error but don't fail the product creation
		fmt.Printf("Warning: failed to update shop product count: %v\n", err)
	}

	// Publish product creation event
	event := &ProductEvent{
		Type:      "product_created",
		ProductID: product.ID,
		ShopID:    req.ShopID,
		Product:   product,
		Timestamp: time.Now().UTC(),
	}
	c.events.PublishProduct(ctx, event)

	return product, nil
}

// CreateOrder creates a new order
func (c *CommerceService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*models.Order, error) {
	// Validate request
	if err := c.validateCreateOrderRequest(req); err != nil {
		return nil, fmt.Errorf("invalid create order request: %v", err)
	}

	// Get shop
	shop, err := c.shopRepo.GetByID(ctx, req.ShopID)
	if err != nil {
		return nil, fmt.Errorf("shop not found: %v", err)
	}

	// Check shop status
	if shop.Status != models.ShopStatusActive {
		return nil, fmt.Errorf("shop is not active")
	}

	// Lock products for inventory update
	var lockedProducts []*models.Product
	productLocks := make([]string, 0, len(req.Items))

	defer func() {
		// Unlock all locked products
		for _, lockKey := range productLocks {
			c.cache.Unlock(ctx, lockKey)
		}
	}()

	// Validate products and lock inventory
	var totalAmount int64
	var orderItems []models.OrderItem

	for _, item := range req.Items {
		// Lock product
		lockKey := fmt.Sprintf("product_lock:%s", item.ProductID)
		locked, err := c.cache.Lock(ctx, lockKey, 30*time.Second)
		if !locked || err != nil {
			return nil, fmt.Errorf("failed to lock product %s", item.ProductID)
		}
		productLocks = append(productLocks, lockKey)

		// Get product
		product, err := c.productRepo.LockForUpdate(ctx, item.ProductID)
		if err != nil {
			return nil, fmt.Errorf("product %s not found: %v", item.ProductID, err)
		}

		// Validate product
		if product.ShopID != req.ShopID {
			return nil, fmt.Errorf("product %s does not belong to shop %s", item.ProductID, req.ShopID)
		}

		if product.Status != models.ProductStatusActive {
			return nil, fmt.Errorf("product %s is not active", item.ProductID)
		}

		// Check inventory
		if c.config.EnableInventoryTracking {
			if product.Inventory < item.Quantity {
				return nil, fmt.Errorf("insufficient inventory for product %s: available %d, requested %d",
					item.ProductID, product.Inventory, item.Quantity)
			}
		}

		// Validate price
		if item.Price != product.Price {
			return nil, fmt.Errorf("price mismatch for product %s: expected %d, provided %d",
				item.ProductID, product.Price, item.Price)
		}

		// Reserve inventory
		if c.config.EnableInventoryTracking {
			product.Inventory -= item.Quantity
			if err := c.productRepo.Update(ctx, product); err != nil {
				return nil, fmt.Errorf("failed to reserve inventory for product %s: %v", item.ProductID, err)
			}
		}

		lockedProducts = append(lockedProducts, product)

		// Create order item
		orderItem := models.OrderItem{
			ProductID: item.ProductID,
			VariantID: item.VariantID,
			Quantity:  item.Quantity,
			UnitPrice: item.Price,
			TotalPrice: int64(item.Quantity) * item.Price,
		}

		orderItems = append(orderItems, orderItem)
		totalAmount += orderItem.TotalPrice
	}

	// Calculate commission
	commission := int64(float64(totalAmount) * c.config.CommissionRate)

	// Create order
	order := &models.Order{
		UserID:          req.UserID,
		ShopID:          req.ShopID,
		Items:           orderItems,
		Status:          models.OrderStatusPending,
		Currency:        req.Currency,
		Subtotal:        totalAmount,
		Tax:             0, // TODO: Implement tax calculation
		ShippingCost:    0, // TODO: Implement shipping calculation
		Commission:      commission,
		Total:           totalAmount,
		ShippingAddress: req.ShippingAddress,
		BillingAddress:  req.BillingAddress,
		Notes:           req.Notes,
	}

	// Set up order before creation
	if err := order.BeforeCreate(); err != nil {
		// Rollback inventory reservations
		c.rollbackInventoryReservations(ctx, lockedProducts, req.Items)
		return nil, fmt.Errorf("failed to prepare order: %v", err)
	}

	// Validate order
	if err := order.Validate(); err != nil {
		// Rollback inventory reservations
		c.rollbackInventoryReservations(ctx, lockedProducts, req.Items)
		return nil, fmt.Errorf("order validation failed: %v", err)
	}

	// Save order
	if err := c.orderRepo.Create(ctx, order); err != nil {
		// Rollback inventory reservations
		c.rollbackInventoryReservations(ctx, lockedProducts, req.Items)
		return nil, fmt.Errorf("failed to create order: %v", err)
	}

	// Update shop order count
	shop.OrderCount++
	shop.UpdatedAt = time.Now().UTC()
	if err := c.shopRepo.Update(ctx, shop); err != nil {
		// Log error but don't fail the order creation
		fmt.Printf("Warning: failed to update shop order count: %v\n", err)
	}

	// Publish order creation event
	event := &OrderEvent{
		Type:      "order_created",
		OrderID:   order.ID,
		UserID:    req.UserID,
		ShopID:    req.ShopID,
		Order:     order,
		Timestamp: time.Now().UTC(),
	}
	c.events.PublishOrder(ctx, event)

	return order, nil
}

// ProcessPayment processes payment for an order
func (c *CommerceService) ProcessPayment(ctx context.Context, orderID uuid.UUID, paymentMethod string) (*PaymentResponse, error) {
	// Get order
	order, err := c.orderRepo.GetByID(ctx, orderID)
	if err != nil {
		return nil, fmt.Errorf("order not found: %v", err)
	}

	// Validate order status
	if order.Status != models.OrderStatusPending {
		return nil, fmt.Errorf("order is not in pending status")
	}

	// Check if order is expired
	if order.IsExpired() {
		// Cancel the order
		if err := c.CancelOrder(ctx, orderID, order.UserID, "Order expired"); err != nil {
			fmt.Printf("Warning: failed to cancel expired order %s: %v\n", orderID, err)
		}
		return nil, fmt.Errorf("order has expired")
	}

	// Create payment request
	paymentReq := &PaymentRequest{
		OrderID:     orderID,
		Amount:      order.Total,
		Currency:    order.Currency,
		Method:      paymentMethod,
		Description: fmt.Sprintf("Payment for order %s", order.ID),
	}

	// Process payment
	paymentResp, err := c.payment.CreatePayment(ctx, paymentReq)
	if err != nil {
		return nil, fmt.Errorf("payment processing failed: %v", err)
	}

	// Update order with payment information
	order.PaymentID = &paymentResp.PaymentID
	order.PaymentMethod = &paymentMethod
	order.Status = models.OrderStatusAwaitingPayment
	order.UpdatedAt = time.Now().UTC()

	if err := c.orderRepo.Update(ctx, order); err != nil {
		// Log error but return successful payment response
		fmt.Printf("Warning: failed to update order with payment info: %v\n", err)
	}

	return paymentResp, nil
}

// ConfirmPayment confirms payment for an order
func (c *CommerceService) ConfirmPayment(ctx context.Context, orderID uuid.UUID, paymentID string) error {
	// Get order
	order, err := c.orderRepo.GetByID(ctx, orderID)
	if err != nil {
		return fmt.Errorf("order not found: %v", err)
	}

	// Validate payment ID
	if order.PaymentID == nil || *order.PaymentID != paymentID {
		return fmt.Errorf("payment ID mismatch")
	}

	// Validate payment with payment service
	paymentStatus, err := c.payment.ValidatePayment(ctx, paymentID)
	if err != nil {
		return fmt.Errorf("payment validation failed: %v", err)
	}

	if paymentStatus.Status != "completed" {
		return fmt.Errorf("payment is not completed")
	}

	// Update order status
	order.Status = models.OrderStatusConfirmed
	order.PaidAt = paymentStatus.PaidAt
	order.UpdatedAt = time.Now().UTC()

	if err := c.orderRepo.Update(ctx, order); err != nil {
		return fmt.Errorf("failed to update order: %v", err)
	}

	// Publish order confirmed event
	event := &OrderEvent{
		Type:      "order_confirmed",
		OrderID:   order.ID,
		UserID:    order.UserID,
		ShopID:    order.ShopID,
		Order:     order,
		Timestamp: time.Now().UTC(),
	}
	c.events.PublishOrder(ctx, event)

	return nil
}

// CancelOrder cancels an order
func (c *CommerceService) CancelOrder(ctx context.Context, orderID, userID uuid.UUID, reason string) error {
	// Get order
	order, err := c.orderRepo.GetByID(ctx, orderID)
	if err != nil {
		return fmt.Errorf("order not found: %v", err)
	}

	// Validate user permission
	if order.UserID != userID {
		return fmt.Errorf("unauthorized to cancel this order")
	}

	// Check if order can be cancelled
	if !order.CanCancel() {
		return fmt.Errorf("order cannot be cancelled in current status: %s", order.Status)
	}

	// Restore inventory
	if err := c.restoreInventory(ctx, order); err != nil {
		// Log error but continue with cancellation
		fmt.Printf("Warning: failed to restore inventory for order %s: %v\n", orderID, err)
	}

	// Process refund if payment was made
	if order.PaymentID != nil && order.PaidAt != nil {
		refundReq := &RefundRequest{
			PaymentID: *order.PaymentID,
			Amount:    order.Total,
			Reason:    reason,
		}

		_, err := c.payment.ProcessRefund(ctx, refundReq)
		if err != nil {
			// Log error but continue with cancellation
			fmt.Printf("Warning: failed to process refund for order %s: %v\n", orderID, err)
		}
	}

	// Update order status
	order.Status = models.OrderStatusCancelled
	order.CancelledAt = func() *time.Time { t := time.Now().UTC(); return &t }()
	order.CancellationReason = &reason
	order.UpdatedAt = time.Now().UTC()

	if err := c.orderRepo.Update(ctx, order); err != nil {
		return fmt.Errorf("failed to update order: %v", err)
	}

	// Publish order cancelled event
	event := &OrderEvent{
		Type:      "order_cancelled",
		OrderID:   order.ID,
		UserID:    order.UserID,
		ShopID:    order.ShopID,
		Order:     order,
		Timestamp: time.Now().UTC(),
	}
	c.events.PublishOrder(ctx, event)

	return nil
}

// GetShop retrieves a shop by ID
func (c *CommerceService) GetShop(ctx context.Context, shopID uuid.UUID) (*models.Shop, error) {
	return c.shopRepo.GetByID(ctx, shopID)
}

// GetProduct retrieves a product by ID
func (c *CommerceService) GetProduct(ctx context.Context, productID uuid.UUID) (*models.Product, error) {
	return c.productRepo.GetByID(ctx, productID)
}

// GetOrder retrieves an order by ID
func (c *CommerceService) GetOrder(ctx context.Context, orderID uuid.UUID) (*models.Order, error) {
	return c.orderRepo.GetByID(ctx, orderID)
}

// SearchProducts searches for products
func (c *CommerceService) SearchProducts(ctx context.Context, query string, filters map[string]interface{}, limit, offset int) ([]*models.Product, error) {
	return c.productRepo.Search(ctx, query, filters, limit, offset)
}

// GetShopProducts retrieves products for a shop
func (c *CommerceService) GetShopProducts(ctx context.Context, shopID uuid.UUID, limit, offset int) ([]*models.Product, error) {
	return c.productRepo.GetByShopID(ctx, shopID, limit, offset)
}

// GetUserOrders retrieves orders for a user
func (c *CommerceService) GetUserOrders(ctx context.Context, userID uuid.UUID, limit, offset int) ([]*models.Order, error) {
	return c.orderRepo.GetByUserID(ctx, userID, limit, offset)
}

// ProcessExpiredOrders processes expired orders
func (c *CommerceService) ProcessExpiredOrders(ctx context.Context) error {
	orders, err := c.orderRepo.GetPendingOrders(ctx)
	if err != nil {
		return fmt.Errorf("failed to get pending orders: %v", err)
	}

	for _, order := range orders {
		if order.IsExpired() {
			// Cancel expired order
			reason := "Order automatically cancelled due to expiration"
			if err := c.CancelOrder(ctx, order.ID, order.UserID, reason); err != nil {
				// Log error but continue with other orders
				fmt.Printf("Warning: failed to cancel expired order %s: %v\n", order.ID, err)
			}
		}
	}

	return nil
}

// Helper methods

func (c *CommerceService) validateCreateShopRequest(req *CreateShopRequest) error {
	if req.OwnerID == uuid.Nil {
		return errors.New("owner_id is required")
	}

	if strings.TrimSpace(req.Name) == "" {
		return errors.New("shop name is required")
	}

	if len(req.Name) > c.config.MaxShopNameLength {
		return fmt.Errorf("shop name exceeds maximum length of %d characters", c.config.MaxShopNameLength)
	}

	if strings.TrimSpace(req.Category) == "" {
		return errors.New("shop category is required")
	}

	return nil
}

func (c *CommerceService) validateCreateProductRequest(req *CreateProductRequest) error {
	if req.ShopID == uuid.Nil {
		return errors.New("shop_id is required")
	}

	if strings.TrimSpace(req.Name) == "" {
		return errors.New("product name is required")
	}

	if len(req.Name) > c.config.MaxProductNameLength {
		return fmt.Errorf("product name exceeds maximum length of %d characters", c.config.MaxProductNameLength)
	}

	if req.Price <= 0 {
		return errors.New("product price must be positive")
	}

	if !req.Currency.IsValid() {
		return fmt.Errorf("invalid currency: %s", req.Currency)
	}

	if req.Inventory < 0 {
		return errors.New("product inventory cannot be negative")
	}

	if len(req.Images) > c.config.MaxProductImages {
		return fmt.Errorf("too many product images: max %d allowed", c.config.MaxProductImages)
	}

	if len(req.Variants) > c.config.MaxProductVariants {
		return fmt.Errorf("too many product variants: max %d allowed", c.config.MaxProductVariants)
	}

	return nil
}

func (c *CommerceService) validateCreateOrderRequest(req *CreateOrderRequest) error {
	if req.UserID == uuid.Nil {
		return errors.New("user_id is required")
	}

	if req.ShopID == uuid.Nil {
		return errors.New("shop_id is required")
	}

	if len(req.Items) == 0 {
		return errors.New("order must have at least one item")
	}

	for i, item := range req.Items {
		if item.ProductID == uuid.Nil {
			return fmt.Errorf("item %d: product_id is required", i)
		}

		if item.Quantity <= 0 {
			return fmt.Errorf("item %d: quantity must be positive", i)
		}

		if item.Price <= 0 {
			return fmt.Errorf("item %d: price must be positive", i)
		}
	}

	if !req.Currency.IsValid() {
		return fmt.Errorf("invalid currency: %s", req.Currency)
	}

	return nil
}

func (c *CommerceService) rollbackInventoryReservations(ctx context.Context, products []*models.Product, items []OrderItem) {
	if !c.config.EnableInventoryTracking {
		return
	}

	for i, product := range products {
		if i >= len(items) {
			break
		}

		// Restore inventory
		product.Inventory += items[i].Quantity
		if err := c.productRepo.Update(ctx, product); err != nil {
			fmt.Printf("Warning: failed to rollback inventory for product %s: %v\n", product.ID, err)
		}
	}
}

func (c *CommerceService) restoreInventory(ctx context.Context, order *models.Order) error {
	if !c.config.EnableInventoryTracking {
		return nil
	}

	for _, item := range order.Items {
		// Lock product
		lockKey := fmt.Sprintf("product_lock:%s", item.ProductID)
		locked, err := c.cache.Lock(ctx, lockKey, 10*time.Second)
		if !locked || err != nil {
			return fmt.Errorf("failed to lock product %s", item.ProductID)
		}

		// Get product
		product, err := c.productRepo.LockForUpdate(ctx, item.ProductID)
		if err != nil {
			c.cache.Unlock(ctx, lockKey)
			return fmt.Errorf("failed to get product %s: %v", item.ProductID, err)
		}

		// Restore inventory
		product.Inventory += item.Quantity
		if err := c.productRepo.Update(ctx, product); err != nil {
			c.cache.Unlock(ctx, lockKey)
			return fmt.Errorf("failed to restore inventory for product %s: %v", item.ProductID, err)
		}

		c.cache.Unlock(ctx, lockKey)
	}

	return nil
}