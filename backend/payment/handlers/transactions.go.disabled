package handlers

import (
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"

	"tchat.dev/payment/services"
	"tchat.dev/shared/middleware"
	"tchat.dev/shared/responses"
)

type TransactionHandler struct {
	transactionService    *services.TransactionService
	paymentGatewayService *services.PaymentGatewayService
	validator             *validator.Validate
}

func NewTransactionHandler(
	transactionService *services.TransactionService,
	paymentGatewayService *services.PaymentGatewayService,
) *TransactionHandler {
	return &TransactionHandler{
		transactionService:    transactionService,
		paymentGatewayService: paymentGatewayService,
		validator:             validator.New(),
	}
}

// SendTransactionRequest represents the request to send money
type SendTransactionRequest struct {
	ToWalletID   uuid.UUID              `json:"to_wallet_id" validate:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
	Amount       float64                `json:"amount" validate:"required,gt=0" example:"100.50"`
	Currency     string                 `json:"currency" validate:"required,len=3" example:"THB"`
	Description  string                 `json:"description,omitempty" validate:"omitempty,max=500" example:"Payment for lunch"`
	Metadata     map[string]interface{} `json:"metadata,omitempty"`
	Pin          string                 `json:"pin,omitempty" validate:"omitempty,len=6,numeric" example:"123456"`
	Biometric    string                 `json:"biometric,omitempty" validate:"omitempty" example:"fingerprint_hash"`
	ScheduledAt  string                 `json:"scheduled_at,omitempty" example:"2024-01-21T10:00:00Z"`
	ExternalID   string                 `json:"external_id,omitempty" validate:"omitempty,max=100" example:"payment_12345"`
}

// TopUpRequest represents the request to top up wallet via payment gateway
type TopUpRequest struct {
	WalletID     uuid.UUID              `json:"wallet_id" validate:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
	Amount       float64                `json:"amount" validate:"required,gt=0" example:"500.00"`
	Currency     string                 `json:"currency" validate:"required,len=3" example:"THB"`
	Gateway      string                 `json:"gateway" validate:"required" example:"omise"`
	Method       string                 `json:"method" validate:"required" example:"credit_card"`
	Description  string                 `json:"description,omitempty" validate:"omitempty,max=500" example:"Wallet top-up"`
	ReturnURL    string                 `json:"return_url,omitempty" validate:"omitempty,url" example:"https://app.tchat.com/payment/success"`
	Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// WithdrawRequest represents the request to withdraw from wallet
type WithdrawRequest struct {
	WalletID      uuid.UUID              `json:"wallet_id" validate:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
	Amount        float64                `json:"amount" validate:"required,gt=0" example:"200.00"`
	Currency      string                 `json:"currency" validate:"required,len=3" example:"THB"`
	Method        string                 `json:"method" validate:"required,oneof=bank_transfer crypto ewallet" example:"bank_transfer"`
	BankAccount   *BankAccountInfo       `json:"bank_account,omitempty"`
	CryptoAddress *CryptoAddressInfo     `json:"crypto_address,omitempty"`
	EWalletInfo   *EWalletInfo           `json:"ewallet_info,omitempty"`
	Description   string                 `json:"description,omitempty" validate:"omitempty,max=500" example:"Withdraw to bank"`
	Pin           string                 `json:"pin,omitempty" validate:"omitempty,len=6,numeric" example:"123456"`
	Biometric     string                 `json:"biometric,omitempty" validate:"omitempty" example:"fingerprint_hash"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

type BankAccountInfo struct {
	BankCode      string `json:"bank_code" validate:"required" example:"KBANK"`
	AccountNumber string `json:"account_number" validate:"required" example:"1234567890"`
	AccountName   string `json:"account_name" validate:"required" example:"John Doe"`
	BankName      string `json:"bank_name,omitempty" example:"Kasikorn Bank"`
	BranchCode    string `json:"branch_code,omitempty" example:"001"`
}

type CryptoAddressInfo struct {
	Currency string `json:"currency" validate:"required" example:"BTC"`
	Address  string `json:"address" validate:"required" example:"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"`
	Network  string `json:"network,omitempty" example:"mainnet"`
}

type EWalletInfo struct {
	Provider    string `json:"provider" validate:"required" example:"truemoney"`
	PhoneNumber string `json:"phone_number" validate:"required,e164" example:"+66812345678"`
	Name        string `json:"name,omitempty" example:"John Doe"`
}

// TransactionResponse represents a transaction in API responses
type TransactionResponse struct {
	ID            uuid.UUID              `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
	WalletID      uuid.UUID              `json:"wallet_id" example:"123e4567-e89b-12d3-a456-426614174001"`
	Amount        float64                `json:"amount" example:"100.50"`
	Currency      string                 `json:"currency" example:"THB"`
	Type          string                 `json:"type" example:"debit"`
	Status        string                 `json:"status" example:"completed"`
	Direction     string                 `json:"direction" example:"outgoing"`
	Description   string                 `json:"description" example:"Payment for lunch"`
	ExternalID    string                 `json:"external_id,omitempty" example:"payment_12345"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
	CreatedAt     string                 `json:"created_at" example:"2024-01-20T15:45:00Z"`
	ProcessedAt   string                 `json:"processed_at,omitempty" example:"2024-01-20T15:45:01Z"`
	FailureReason string                 `json:"failure_reason,omitempty" example:"Insufficient balance"`
	FromWallet    *WalletInfo            `json:"from_wallet,omitempty"`
	ToWallet      *WalletInfo            `json:"to_wallet,omitempty"`
	Fee           *FeeInfo               `json:"fee,omitempty"`
}

type WalletInfo struct {
	ID       uuid.UUID `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
	UserID   uuid.UUID `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174001"`
	Currency string    `json:"currency" example:"THB"`
	Name     string    `json:"name,omitempty" example:"Main Wallet"`
}

type FeeInfo struct {
	Amount   float64 `json:"amount" example:"2.50"`
	Currency string  `json:"currency" example:"THB"`
	Type     string  `json:"type" example:"transfer_fee"`
}

// PaymentResponse represents a payment gateway transaction
type PaymentResponse struct {
	PaymentID     uuid.UUID              `json:"payment_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	WalletID      uuid.UUID              `json:"wallet_id" example:"123e4567-e89b-12d3-a456-426614174001"`
	Amount        float64                `json:"amount" example:"500.00"`
	Currency      string                 `json:"currency" example:"THB"`
	Gateway       string                 `json:"gateway" example:"omise"`
	Method        string                 `json:"method" example:"credit_card"`
	Status        string                 `json:"status" example:"pending"`
	GatewayTxnID  string                 `json:"gateway_txn_id,omitempty" example:"txn_12345"`
	RedirectURL   string                 `json:"redirect_url,omitempty" example:"https://pay.omise.co/checkout/12345"`
	CreatedAt     string                 `json:"created_at" example:"2024-01-20T15:45:00Z"`
	ExpiresAt     string                 `json:"expires_at,omitempty" example:"2024-01-20T16:00:00Z"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// @Summary Send money between wallets
// @Description Transfer money from user's wallet to another wallet
// @Tags transactions
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body SendTransactionRequest true "Transaction request"
// @Success 201 {object} responses.DataResponse{data=TransactionResponse}
// @Failure 400 {object} responses.ErrorResponse
// @Failure 401 {object} responses.ErrorResponse "Unauthorized"
// @Failure 403 {object} responses.ErrorResponse "Authentication required"
// @Failure 404 {object} responses.ErrorResponse "Wallet not found"
// @Failure 422 {object} responses.ErrorResponse "Insufficient balance"
// @Failure 500 {object} responses.ErrorResponse
// @Router /transactions/send [post]
func (h *TransactionHandler) SendTransaction(c *gin.Context) {
	var req SendTransactionRequest

	// Parse request body
	if err := c.ShouldBindJSON(&req); err != nil {
		responses.BadRequestResponse(c, err.Error())
		return
	}

	// Validate request
	if err := h.validator.Struct(&req); err != nil {
		responses.ValidationErrorResponse(c, err)
		return
	}

	// Get user ID from context
	userID, exists := c.Get("user_id")
	if !exists {
		responses.UnauthorizedResponse(c, "Authentication required.")
		return
	}

	userUUID, ok := userID.(uuid.UUID)
	if !ok {
		responses.InternalErrorResponse(c, "Invalid user context.")
		return
	}

	// Normalize currency
	req.Currency = strings.ToUpper(strings.TrimSpace(req.Currency))

	// Verify PIN/Biometric if required for this amount
	if err := h.verifyAuthentication(c.Request.Context(), userUUID, req.Amount, req.Pin, req.Biometric); err != nil {
		responses.ForbiddenResponse(c, err.Error())
		return
	}

	// Get user's default wallet for this currency
	fromWalletID, err := h.getUserDefaultWallet(c.Request.Context(), userUUID, req.Currency)
	if err != nil {
		responses.BadRequestResponse(c, "No default wallet found for the specified currency.")
		return
	}

	// Build service request
	serviceReq := &services.ProcessTransactionRequest{
		FromWalletID: fromWalletID,
		ToWalletID:   req.ToWalletID,
		Amount:       req.Amount,
		Currency:     req.Currency,
		Type:         "transfer",
		Description:  req.Description,
		Metadata:     req.Metadata,
		ExternalID:   req.ExternalID,
	}

	// Process transaction
	transaction, err := h.transactionService.ProcessTransaction(c.Request.Context(), serviceReq)
	if err != nil {
		switch {
		case strings.Contains(err.Error(), "wallet not found"):
			responses.NotFoundResponse(c, "The destination wallet does not exist.")
			return
		case strings.Contains(err.Error(), "insufficient balance"):
			responses.ErrorResponse(c, http.StatusUnprocessableEntity, "Insufficient balance", "Not enough balance to complete this transaction.")
			return
		case strings.Contains(err.Error(), "transaction limit"):
			responses.BadRequestResponse(c, "This transaction exceeds your daily/monthly limit.")
			return
		case strings.Contains(err.Error(), "wallet suspended"):
			responses.BadRequestResponse(c, "One of the wallets is currently suspended.")
			return
		case strings.Contains(err.Error(), "same wallet"):
			responses.BadRequestResponse(c, "Cannot transfer to the same wallet.")
			return
		default:
			responses.InternalErrorResponse(c, "Failed to process transaction.")
			return
		}
	}

	// Convert to response format
	transactionResponse := h.convertToTransactionResponse(transaction)

	// Log transaction
	middleware.LogInfo(c, "Transaction sent", gin.H{
		"transaction_id": transaction.ID,
		"from_wallet":    fromWalletID,
		"to_wallet":      req.ToWalletID,
		"amount":         req.Amount,
		"currency":       req.Currency,
		"external_id":    req.ExternalID,
	})

	c.JSON(http.StatusCreated, responses.DataResponse{
		Success: true,
		Data:    transactionResponse,
	})
}

// @Summary Top up wallet via payment gateway
// @Description Add money to wallet using external payment gateway
// @Tags transactions
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body TopUpRequest true "Top-up request"
// @Success 201 {object} responses.DataResponse{data=PaymentResponse}
// @Failure 400 {object} responses.ErrorResponse
// @Failure 401 {object} responses.ErrorResponse "Unauthorized"
// @Failure 404 {object} responses.ErrorResponse "Wallet not found"
// @Failure 500 {object} responses.ErrorResponse
// @Router /transactions/topup [post]
func (h *TransactionHandler) TopUpWallet(c *gin.Context) {
	var req TopUpRequest

	// Parse request body
	if err := c.ShouldBindJSON(&req); err != nil {
		responses.BadRequestResponse(c, err.Error())
		return
	}

	// Validate request
	if err := h.validator.Struct(&req); err != nil {
		responses.ValidationErrorResponse(c, err)
		return
	}

	// Get user ID from context
	userID, exists := c.Get("user_id")
	if !exists {
		responses.UnauthorizedResponse(c, "Authentication required.")
		return
	}

	userUUID, ok := userID.(uuid.UUID)
	if !ok {
		responses.InternalErrorResponse(c, "Invalid user context.")
		return
	}

	// Normalize currency
	req.Currency = strings.ToUpper(strings.TrimSpace(req.Currency))

	// Verify wallet ownership
	if err := h.verifyWalletOwnership(c.Request.Context(), req.WalletID, userUUID); err != nil {
		responses.ForbiddenResponse(c, "You don't have access to this wallet.")
		return
	}

	// Build service request
	serviceReq := &services.CreatePaymentRequest{
		WalletID:    req.WalletID,
		Amount:      req.Amount,
		Currency:    req.Currency,
		Gateway:     req.Gateway,
		Method:      req.Method,
		Description: req.Description,
		ReturnURL:   req.ReturnURL,
		Metadata:    req.Metadata,
	}

	// Create payment
	payment, err := h.paymentGatewayService.CreatePayment(c.Request.Context(), serviceReq)
	if err != nil {
		switch {
		case strings.Contains(err.Error(), "wallet not found"):
			responses.NotFoundResponse(c, "The specified wallet does not exist.")
			return
		case strings.Contains(err.Error(), "unsupported gateway"):
			responses.BadRequestResponse(c, "The specified payment gateway is not supported.")
			return
		case strings.Contains(err.Error(), "amount too small"):
			responses.BadRequestResponse(c, "The amount is below the minimum required for this gateway.")
			return
		case strings.Contains(err.Error(), "amount too large"):
			responses.BadRequestResponse(c, "The amount exceeds the maximum allowed for this gateway.")
			return
		default:
			responses.InternalErrorResponse(c, "Failed to create payment.")
			return
		}
	}

	// Convert to response format
	paymentResponse := h.convertToPaymentResponse(payment)

	// Log top-up initiation
	middleware.LogInfo(c, "Wallet top-up initiated", gin.H{
		"payment_id": payment.ID,
		"wallet_id":  req.WalletID,
		"amount":     req.Amount,
		"currency":   req.Currency,
		"gateway":    req.Gateway,
		"method":     req.Method,
	})

	c.JSON(http.StatusCreated, responses.DataResponse{
		Success: true,
		Data:    paymentResponse,
	})
}

// @Summary Withdraw from wallet
// @Description Withdraw money from wallet to external account
// @Tags transactions
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body WithdrawRequest true "Withdrawal request"
// @Success 201 {object} responses.DataResponse{data=TransactionResponse}
// @Failure 400 {object} responses.ErrorResponse
// @Failure 401 {object} responses.ErrorResponse "Unauthorized"
// @Failure 403 {object} responses.ErrorResponse "Authentication required"
// @Failure 404 {object} responses.ErrorResponse "Wallet not found"
// @Failure 422 {object} responses.ErrorResponse "Insufficient balance"
// @Failure 500 {object} responses.ErrorResponse
// @Router /transactions/withdraw [post]
func (h *TransactionHandler) WithdrawFromWallet(c *gin.Context) {
	var req WithdrawRequest

	// Parse request body
	if err := c.ShouldBindJSON(&req); err != nil {
		responses.BadRequestResponse(c, err.Error())
		return
	}

	// Validate request
	if err := h.validator.Struct(&req); err != nil {
		responses.ValidationErrorResponse(c, err)
		return
	}

	// Get user ID from context
	userID, exists := c.Get("user_id")
	if !exists {
		responses.UnauthorizedResponse(c, "Authentication required.")
		return
	}

	userUUID, ok := userID.(uuid.UUID)
	if !ok {
		responses.InternalErrorResponse(c, "Invalid user context.")
		return
	}

	// Normalize currency
	req.Currency = strings.ToUpper(strings.TrimSpace(req.Currency))

	// Verify wallet ownership
	if err := h.verifyWalletOwnership(c.Request.Context(), req.WalletID, userUUID); err != nil {
		responses.ForbiddenResponse(c, "You don't have access to this wallet.")
		return
	}

	// Verify PIN/Biometric (withdrawals always require authentication)
	if err := h.verifyAuthentication(c.Request.Context(), userUUID, req.Amount, req.Pin, req.Biometric); err != nil {
		responses.ForbiddenResponse(c, err.Error())
		return
	}

	// Validate withdrawal destination based on method
	if err := h.validateWithdrawalDestination(&req); err != nil {
		responses.BadRequestResponse(c, err.Error())
		return
	}

	// Build service request - this would create a withdrawal transaction
	serviceReq := &services.CreateTransactionRequest{
		WalletID:    req.WalletID,
		Amount:      -req.Amount, // Negative for withdrawal
		Currency:    req.Currency,
		Type:        "debit",
		Status:      "pending",
		Direction:   "outgoing",
		Description: req.Description,
		Metadata:    req.Metadata,
	}

	// Create withdrawal transaction
	transaction, err := h.transactionService.CreateTransaction(c.Request.Context(), serviceReq)
	if err != nil {
		switch {
		case strings.Contains(err.Error(), "wallet not found"):
			responses.NotFoundResponse(c, "The specified wallet does not exist.")
			return
		case strings.Contains(err.Error(), "insufficient balance"):
			responses.ErrorResponse(c, http.StatusUnprocessableEntity, "Insufficient balance", "Not enough balance to complete this withdrawal.")
			return
		case strings.Contains(err.Error(), "withdrawal limit"):
			responses.BadRequestResponse(c, "This withdrawal exceeds your daily/monthly limit.")
			return
		case strings.Contains(err.Error(), "wallet suspended"):
			responses.BadRequestResponse(c, "This wallet is currently suspended.")
			return
		default:
			responses.InternalErrorResponse(c, "Failed to process withdrawal.")
			return
		}
	}

	// Process withdrawal asynchronously (would integrate with payment processors)
	go h.processWithdrawalAsync(c.Request.Context(), transaction, &req)

	// Convert to response format
	transactionResponse := h.convertToTransactionResponse(transaction)

	// Log withdrawal initiation
	middleware.LogInfo(c, "Withdrawal initiated", gin.H{
		"transaction_id": transaction.ID,
		"wallet_id":      req.WalletID,
		"amount":         req.Amount,
		"currency":       req.Currency,
		"method":         req.Method,
	})

	c.JSON(http.StatusCreated, responses.DataResponse{
		Success: true,
		Data:    transactionResponse,
	})
}

// @Summary Get transaction history
// @Description Get paginated transaction history for user's wallets
// @Tags transactions
// @Produce json
// @Security BearerAuth
// @Param wallet_id query string false "Filter by wallet ID"
// @Param type query string false "Filter by transaction type" Enums(credit,debit)
// @Param status query string false "Filter by status" Enums(pending,processing,completed,failed,cancelled)
// @Param start_date query string false "Start date (YYYY-MM-DD)" example:"2024-01-01"
// @Param end_date query string false "End date (YYYY-MM-DD)" example:"2024-01-31"
// @Param limit query int false "Number of transactions to return" default(20) minimum(1) maximum(100)
// @Param offset query int false "Number of transactions to skip" default(0) minimum(0)
// @Success 200 {object} responses.DataResponse{data=map[string]interface{}}
// @Failure 400 {object} responses.ErrorResponse
// @Failure 401 {object} responses.ErrorResponse "Unauthorized"
// @Failure 500 {object} responses.ErrorResponse
// @Router /transactions [get]
func (h *TransactionHandler) GetTransactionHistory(c *gin.Context) {
	// Get user ID from context
	userID, exists := c.Get("user_id")
	if !exists {
		responses.UnauthorizedResponse(c, "Authentication required.")
		return
	}

	userUUID, ok := userID.(uuid.UUID)
	if !ok {
		responses.InternalErrorResponse(c, "Invalid user context.")
		return
	}

	// Parse query parameters
	var walletID uuid.UUID
	if walletIDStr := c.Query("wallet_id"); walletIDStr != "" {
		if id, err := uuid.Parse(walletIDStr); err == nil {
			walletID = id
		} else {
			responses.BadRequestResponse(c, "Wallet ID must be a valid UUID.")
			return
		}
	}

	transactionType := c.Query("type")
	status := c.Query("status")

	var startDate, endDate *time.Time
	if startDateStr := c.Query("start_date"); startDateStr != "" {
		if date, err := time.Parse("2006-01-02", startDateStr); err == nil {
			startDate = &date
		}
	}
	if endDateStr := c.Query("end_date"); endDateStr != "" {
		if date, err := time.Parse("2006-01-02", endDateStr); err == nil {
			endDate = &date
		}
	}

	limit := 20
	if l := c.Query("limit"); l != "" {
		if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 && parsed <= 100 {
			limit = parsed
		}
	}

	offset := 0
	if o := c.Query("offset"); o != "" {
		if parsed, err := strconv.Atoi(o); err == nil && parsed >= 0 {
			offset = parsed
		}
	}

	// If no specific wallet, get all user's wallets
	if walletID == uuid.Nil {
		transactions, total, err := h.getUserTransactionHistory(c.Request.Context(), userUUID, transactionType, status, startDate, endDate, limit, offset)
		if err != nil {
			responses.InternalErrorResponse(c, "Unable to retrieve transaction history.")
			return
		}

		// Convert to response format
		transactionResponses := make([]TransactionResponse, len(transactions))
		for i, transaction := range transactions {
			transactionResponses[i] = h.convertToTransactionResponse(transaction)
		}

		// Build response data
		data := gin.H{
			"transactions": transactionResponses,
			"total":        total,
			"limit":        limit,
			"offset":       offset,
			"has_more":     total > int64(offset+len(transactions)),
		}

		responses.DataResponse(c, data)
		return
	}

	// Verify wallet ownership
	if err := h.verifyWalletOwnership(c.Request.Context(), walletID, userUUID); err != nil {
		responses.ForbiddenResponse(c, "You don't have access to this wallet.")
		return
	}

	// Build service request
	req := &services.GetTransactionHistoryRequest{
		WalletID:  walletID,
		Type:      transactionType,
		Status:    status,
		StartDate: startDate,
		EndDate:   endDate,
		Limit:     limit,
		Offset:    offset,
	}

	// Get transaction history
	transactions, total, err := h.transactionService.GetTransactionHistory(c.Request.Context(), req)
	if err != nil {
		responses.InternalErrorResponse(c, "Unable to retrieve transaction history.")
		return
	}

	// Convert to response format
	transactionResponses := make([]TransactionResponse, len(transactions))
	for i, transaction := range transactions {
		transactionResponses[i] = h.convertToTransactionResponse(transaction)
	}

	// Build response data
	data := gin.H{
		"transactions": transactionResponses,
		"total":        total,
		"limit":        limit,
		"offset":       offset,
		"has_more":     total > int64(offset+len(transactions)),
		"wallet_id":    walletID,
	}

	responses.DataResponse(c, data)
}

// @Summary Get transaction by ID
// @Description Get detailed information about a specific transaction
// @Tags transactions
// @Produce json
// @Security BearerAuth
// @Param id path string true "Transaction ID"
// @Success 200 {object} responses.DataResponse{data=TransactionResponse}
// @Failure 400 {object} responses.ErrorResponse
// @Failure 401 {object} responses.ErrorResponse "Unauthorized"
// @Failure 403 {object} responses.ErrorResponse "Access denied"
// @Failure 404 {object} responses.ErrorResponse "Transaction not found"
// @Failure 500 {object} responses.ErrorResponse
// @Router /transactions/{id} [get]
func (h *TransactionHandler) GetTransaction(c *gin.Context) {
	// Parse transaction ID
	transactionIDStr := c.Param("id")
	transactionID, err := uuid.Parse(transactionIDStr)
	if err != nil {
		responses.BadRequestResponse(c, "Transaction ID must be a valid UUID.")
		return
	}

	// Get user ID from context
	userID, exists := c.Get("user_id")
	if !exists {
		responses.UnauthorizedResponse(c, "Authentication required.")
		return
	}

	userUUID, ok := userID.(uuid.UUID)
	if !ok {
		responses.InternalErrorResponse(c, "Invalid user context.")
		return
	}

	// Get transaction
	transaction, err := h.transactionService.GetTransactionByID(c.Request.Context(), transactionID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			responses.NotFoundResponse(c, "The specified transaction does not exist.")
			return
		}
		responses.InternalErrorResponse(c, "Unable to retrieve transaction.")
		return
	}

	// Verify user has access to this transaction (via wallet ownership)
	if err := h.verifyTransactionAccess(c.Request.Context(), transaction, userUUID); err != nil {
		responses.ForbiddenResponse(c, "You don't have access to this transaction.")
		return
	}

	// Convert to response format
	transactionResponse := h.convertToTransactionResponse(transaction)

	responses.DataResponse(c, transactionResponse)
}

// Helper functions

func (h *TransactionHandler) verifyAuthentication(ctx context.Context, userID uuid.UUID, amount float64, pin, biometric string) error {
	// Implement PIN/biometric verification logic
	// This would integrate with your authentication service
	return nil // Placeholder
}

func (h *TransactionHandler) getUserDefaultWallet(ctx context.Context, userID uuid.UUID, currency string) (uuid.UUID, error) {
	// Implement logic to get user's default wallet for currency
	// This would integrate with your wallet service
	return uuid.New(), nil // Placeholder
}

func (h *TransactionHandler) verifyWalletOwnership(ctx context.Context, walletID, userID uuid.UUID) error {
	// Implement wallet ownership verification
	// This would check if the user owns the wallet
	return nil // Placeholder
}

func (h *TransactionHandler) validateWithdrawalDestination(req *WithdrawRequest) error {
	switch req.Method {
	case "bank_transfer":
		if req.BankAccount == nil {
			return fmt.Errorf("bank account information is required for bank transfers")
		}
		// Validate bank account info
	case "crypto":
		if req.CryptoAddress == nil {
			return fmt.Errorf("crypto address information is required for crypto withdrawals")
		}
		// Validate crypto address
	case "ewallet":
		if req.EWalletInfo == nil {
			return fmt.Errorf("e-wallet information is required for e-wallet withdrawals")
		}
		// Validate e-wallet info
	default:
		return fmt.Errorf("unsupported withdrawal method: %s", req.Method)
	}
	return nil
}

func (h *TransactionHandler) processWithdrawalAsync(ctx context.Context, transaction interface{}, req *WithdrawRequest) {
	// Implement asynchronous withdrawal processing
	// This would integrate with various withdrawal providers
}

func (h *TransactionHandler) getUserTransactionHistory(ctx context.Context, userID uuid.UUID, transactionType, status string, startDate, endDate *time.Time, limit, offset int) ([]interface{}, int64, error) {
	// Implement logic to get all transactions for user across all wallets
	// This would join wallet and transaction data
	return []interface{}{}, 0, nil // Placeholder
}

func (h *TransactionHandler) verifyTransactionAccess(ctx context.Context, transaction interface{}, userID uuid.UUID) error {
	// Implement transaction access verification
	// This would check if user owns the wallet associated with the transaction
	return nil // Placeholder
}

func (h *TransactionHandler) convertToTransactionResponse(transaction interface{}) TransactionResponse {
	// This is a simplified conversion - in a real implementation,
	// you would properly convert from your transaction model to the response
	return TransactionResponse{
		// Populate fields from transaction model
		// This is just a placeholder structure
	}
}

func (h *TransactionHandler) convertToPaymentResponse(payment interface{}) PaymentResponse {
	// This is a simplified conversion - in a real implementation,
	// you would properly convert from your payment model to the response
	return PaymentResponse{
		// Populate fields from payment model
		// This is just a placeholder structure
	}
}

// RegisterTransactionRoutes registers all transaction-related routes
func RegisterTransactionRoutes(
	router *gin.RouterGroup,
	transactionService *services.TransactionService,
	paymentGatewayService *services.PaymentGatewayService,
) {
	handler := NewTransactionHandler(transactionService, paymentGatewayService)

	// Protected transaction routes
	transactions := router.Group("/transactions")
	transactions.Use(middleware.AuthRequired())
	{
		transactions.GET("", handler.GetTransactionHistory)
		transactions.GET("/:id", handler.GetTransaction)
		transactions.POST("/send", handler.SendTransaction)
		transactions.POST("/topup", handler.TopUpWallet)
		transactions.POST("/withdraw", handler.WithdrawFromWallet)
	}
}

// RegisterTransactionRoutesWithMiddleware registers transaction routes with custom middleware
func RegisterTransactionRoutesWithMiddleware(
	router *gin.RouterGroup,
	transactionService *services.TransactionService,
	paymentGatewayService *services.PaymentGatewayService,
	middlewares ...gin.HandlerFunc,
) {
	handler := NewTransactionHandler(transactionService, paymentGatewayService)

	// Protected transaction routes with middleware
	transactions := router.Group("/transactions")
	allMiddlewares := append(middlewares, middleware.AuthRequired())
	transactions.Use(allMiddlewares...)
	{
		transactions.GET("", handler.GetTransactionHistory)
		transactions.GET("/:id", handler.GetTransaction)
		transactions.POST("/send", handler.SendTransaction)
		transactions.POST("/topup", handler.TopUpWallet)
		transactions.POST("/withdraw", handler.WithdrawFromWallet)
	}
}