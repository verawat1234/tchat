-- Video.sq
-- SQLDelight schema for video offline caching and synchronization
-- Matches backend video models from backend/video/models/

-- Video Content Table
-- Stores video metadata and content information
CREATE TABLE IF NOT EXISTS VideoContent (
    id TEXT PRIMARY KEY NOT NULL,
    creator_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    thumbnail_url TEXT,
    video_url TEXT NOT NULL,
    duration_seconds INTEGER NOT NULL,
    file_size INTEGER NOT NULL,
    mime_type TEXT NOT NULL,
    resolution TEXT NOT NULL,
    bitrate INTEGER NOT NULL,
    framerate REAL NOT NULL,
    codec TEXT NOT NULL,
    upload_status TEXT NOT NULL DEFAULT 'processing',
    availability_status TEXT NOT NULL DEFAULT 'available',
    content_rating TEXT NOT NULL DEFAULT 'general',
    tags TEXT NOT NULL DEFAULT '[]',
    category TEXT,
    view_count INTEGER NOT NULL DEFAULT 0,
    like_count INTEGER NOT NULL DEFAULT 0,
    comment_count INTEGER NOT NULL DEFAULT 0,
    share_count INTEGER NOT NULL DEFAULT 0,
    is_monetized INTEGER NOT NULL DEFAULT 0,
    price REAL,
    currency TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    published_at TEXT,
    deleted_at TEXT,
    -- Indexing for performance
    CONSTRAINT chk_upload_status CHECK(upload_status IN ('processing', 'available', 'unavailable', 'archived', 'deleted')),
    CONSTRAINT chk_availability_status CHECK(availability_status IN ('processing', 'available', 'unavailable', 'archived', 'deleted')),
    CONSTRAINT chk_content_rating CHECK(content_rating IN ('general', 'teen', 'mature', 'adult'))
);

CREATE INDEX IF NOT EXISTS idx_video_creator ON VideoContent(creator_id);
CREATE INDEX IF NOT EXISTS idx_video_category ON VideoContent(category);
CREATE INDEX IF NOT EXISTS idx_video_status ON VideoContent(upload_status, availability_status);
CREATE INDEX IF NOT EXISTS idx_video_created ON VideoContent(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_video_views ON VideoContent(view_count DESC);

-- Playback Session Table
-- Stores active playback sessions for cross-platform sync
CREATE TABLE IF NOT EXISTS PlaybackSession (
    id TEXT PRIMARY KEY NOT NULL,
    video_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    platform TEXT NOT NULL,
    device_id TEXT NOT NULL,
    current_position REAL NOT NULL DEFAULT 0.0,
    total_duration REAL NOT NULL,
    playback_speed REAL NOT NULL DEFAULT 1.0,
    quality TEXT NOT NULL DEFAULT 'auto',
    volume REAL NOT NULL DEFAULT 1.0,
    state TEXT NOT NULL DEFAULT 'paused',
    buffered_seconds REAL NOT NULL DEFAULT 0.0,
    buffer_percentage REAL NOT NULL DEFAULT 0.0,
    is_stalled INTEGER NOT NULL DEFAULT 0,
    last_stall_time TEXT,
    is_fullscreen INTEGER NOT NULL DEFAULT 0,
    is_picture_in_picture INTEGER NOT NULL DEFAULT 0,
    last_sync_time TEXT NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(video_id) REFERENCES VideoContent(id) ON DELETE CASCADE,
    CONSTRAINT chk_platform CHECK(platform IN ('web', 'ios', 'android', 'mobile_web')),
    CONSTRAINT chk_state CHECK(state IN ('playing', 'paused', 'buffering', 'ended', 'error')),
    CONSTRAINT chk_quality CHECK(quality IN ('auto', 'low', 'medium', 'high', 'ultra'))
);

CREATE INDEX IF NOT EXISTS idx_session_video ON PlaybackSession(video_id);
CREATE INDEX IF NOT EXISTS idx_session_user ON PlaybackSession(user_id);
CREATE INDEX IF NOT EXISTS idx_session_platform ON PlaybackSession(platform);
CREATE INDEX IF NOT EXISTS idx_session_updated ON PlaybackSession(updated_at DESC);

-- Viewing History Table
-- Tracks user's video viewing history for recommendations
CREATE TABLE IF NOT EXISTS ViewingHistory (
    id TEXT PRIMARY KEY NOT NULL,
    user_id TEXT NOT NULL,
    video_id TEXT NOT NULL,
    watched_seconds REAL NOT NULL,
    completion_percentage REAL NOT NULL,
    last_watched_position REAL NOT NULL,
    watch_count INTEGER NOT NULL DEFAULT 1,
    platform TEXT NOT NULL,
    device_id TEXT NOT NULL,
    is_completed INTEGER NOT NULL DEFAULT 0,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    last_watched_at TEXT NOT NULL,
    FOREIGN KEY(video_id) REFERENCES VideoContent(id) ON DELETE CASCADE,
    CONSTRAINT chk_platform CHECK(platform IN ('web', 'ios', 'android', 'mobile_web'))
);

CREATE INDEX IF NOT EXISTS idx_history_user ON ViewingHistory(user_id);
CREATE INDEX IF NOT EXISTS idx_history_video ON ViewingHistory(video_id);
CREATE INDEX IF NOT EXISTS idx_history_watched ON ViewingHistory(last_watched_at DESC);
CREATE INDEX IF NOT EXISTS idx_history_user_video ON ViewingHistory(user_id, video_id);

-- Synchronization State Table
-- Manages cross-platform sync state and conflict resolution
CREATE TABLE IF NOT EXISTS SyncState (
    id TEXT PRIMARY KEY NOT NULL,
    user_id TEXT NOT NULL,
    video_id TEXT NOT NULL,
    session_id TEXT NOT NULL,
    synced_platforms TEXT NOT NULL DEFAULT '[]',
    last_sync_time TEXT NOT NULL,
    conflict_detected INTEGER NOT NULL DEFAULT 0,
    conflict_resolution TEXT,
    sync_version INTEGER NOT NULL DEFAULT 1,
    pending_changes TEXT NOT NULL DEFAULT '[]',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(video_id) REFERENCES VideoContent(id) ON DELETE CASCADE,
    FOREIGN KEY(session_id) REFERENCES PlaybackSession(id) ON DELETE CASCADE,
    CONSTRAINT chk_conflict_resolution CHECK(conflict_resolution IN ('latest_wins', 'authority_platform', 'average_position', 'manual_resolution'))
);

CREATE INDEX IF NOT EXISTS idx_sync_user ON SyncState(user_id);
CREATE INDEX IF NOT EXISTS idx_sync_video ON SyncState(video_id);
CREATE INDEX IF NOT EXISTS idx_sync_session ON SyncState(session_id);
CREATE INDEX IF NOT EXISTS idx_sync_updated ON SyncState(updated_at DESC);

-- Queries

-- Video Content Queries
getVideoById:
SELECT * FROM VideoContent WHERE id = ?;

getAllVideos:
SELECT * FROM VideoContent
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT :limit OFFSET :offset;

getVideosByCreator:
SELECT * FROM VideoContent
WHERE creator_id = :creatorId AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT :limit OFFSET :offset;

getVideosByCategory:
SELECT * FROM VideoContent
WHERE category = :category AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT :limit OFFSET :offset;

getTrendingVideos:
SELECT * FROM VideoContent
WHERE deleted_at IS NULL
ORDER BY view_count DESC, created_at DESC
LIMIT :limit;

searchVideos:
SELECT * FROM VideoContent
WHERE (title LIKE :query OR description LIKE :query OR tags LIKE :query)
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT :limit OFFSET :offset;

insertVideo:
INSERT OR REPLACE INTO VideoContent VALUES ?;

updateVideo:
UPDATE VideoContent
SET title = :title,
    description = :description,
    thumbnail_url = :thumbnailUrl,
    view_count = :viewCount,
    like_count = :likeCount,
    comment_count = :commentCount,
    share_count = :shareCount,
    updated_at = :updatedAt
WHERE id = :id;

deleteVideo:
UPDATE VideoContent
SET deleted_at = :deletedAt
WHERE id = :id;

incrementViewCount:
UPDATE VideoContent
SET view_count = view_count + 1,
    updated_at = :updatedAt
WHERE id = :id;

-- Playback Session Queries
getPlaybackSessionById:
SELECT * FROM PlaybackSession WHERE id = ?;

getPlaybackSessionByVideoAndUser:
SELECT * FROM PlaybackSession
WHERE video_id = :videoId AND user_id = :userId
ORDER BY updated_at DESC
LIMIT 1;

getActivePlaybackSessions:
SELECT * FROM PlaybackSession
WHERE user_id = :userId
  AND state IN ('playing', 'paused', 'buffering')
ORDER BY updated_at DESC;

insertPlaybackSession:
INSERT OR REPLACE INTO PlaybackSession VALUES ?;

updatePlaybackPosition:
UPDATE PlaybackSession
SET current_position = :position,
    state = :state,
    last_sync_time = :syncTime,
    updated_at = :updatedAt
WHERE id = :id;

updatePlaybackQuality:
UPDATE PlaybackSession
SET quality = :quality,
    updated_at = :updatedAt
WHERE id = :id;

updateBufferHealth:
UPDATE PlaybackSession
SET buffered_seconds = :bufferedSeconds,
    buffer_percentage = :bufferPercentage,
    is_stalled = :isStalled,
    last_stall_time = :lastStallTime,
    updated_at = :updatedAt
WHERE id = :id;

deletePlaybackSession:
DELETE FROM PlaybackSession WHERE id = ?;

-- Viewing History Queries
getViewingHistoryById:
SELECT * FROM ViewingHistory WHERE id = ?;

getViewingHistoryByUser:
SELECT vh.*, vc.title, vc.thumbnail_url, vc.duration_seconds
FROM ViewingHistory vh
JOIN VideoContent vc ON vh.video_id = vc.id
WHERE vh.user_id = :userId
ORDER BY vh.last_watched_at DESC
LIMIT :limit OFFSET :offset;

getViewingHistoryByVideo:
SELECT * FROM ViewingHistory
WHERE video_id = :videoId
ORDER BY last_watched_at DESC;

insertViewingHistory:
INSERT OR REPLACE INTO ViewingHistory VALUES ?;

updateViewingHistory:
UPDATE ViewingHistory
SET watched_seconds = :watchedSeconds,
    completion_percentage = :completionPercentage,
    last_watched_position = :lastWatchedPosition,
    watch_count = watch_count + 1,
    is_completed = :isCompleted,
    updated_at = :updatedAt,
    last_watched_at = :lastWatchedAt
WHERE id = :id;

deleteViewingHistory:
DELETE FROM ViewingHistory WHERE id = ?;

-- Synchronization State Queries
getSyncStateById:
SELECT * FROM SyncState WHERE id = ?;

getSyncStateBySession:
SELECT * FROM SyncState
WHERE session_id = :sessionId
ORDER BY updated_at DESC
LIMIT 1;

getSyncStateByUserAndVideo:
SELECT * FROM SyncState
WHERE user_id = :userId AND video_id = :videoId
ORDER BY updated_at DESC
LIMIT 1;

insertSyncState:
INSERT OR REPLACE INTO SyncState VALUES ?;

updateSyncState:
UPDATE SyncState
SET synced_platforms = :syncedPlatforms,
    last_sync_time = :lastSyncTime,
    conflict_detected = :conflictDetected,
    conflict_resolution = :conflictResolution,
    sync_version = sync_version + 1,
    pending_changes = :pendingChanges,
    updated_at = :updatedAt
WHERE id = :id;

deleteSyncState:
DELETE FROM SyncState WHERE id = ?;

-- Cache Management Queries
clearOldCache:
DELETE FROM VideoContent
WHERE created_at < :cutoffTime
  AND deleted_at IS NOT NULL;

clearOldSessions:
DELETE FROM PlaybackSession
WHERE updated_at < :cutoffTime
  AND state = 'ended';

clearOldHistory:
DELETE FROM ViewingHistory
WHERE last_watched_at < :cutoffTime;

getTableSizes:
SELECT
    'VideoContent', COUNT(*) FROM VideoContent
UNION ALL
SELECT
    'PlaybackSession', COUNT(*) FROM PlaybackSession
UNION ALL
SELECT
    'ViewingHistory', COUNT(*) FROM ViewingHistory
UNION ALL
SELECT
    'SyncState', COUNT(*) FROM SyncState;