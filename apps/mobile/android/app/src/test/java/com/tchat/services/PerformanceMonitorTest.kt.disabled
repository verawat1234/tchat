package com.tchat.services

import android.app.ActivityManager
import android.content.Context
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

/**
 * Unit tests for PerformanceMonitor
 * 
 * Tests cover:
 * - App launch tracking
 * - Navigation performance
 * - Memory monitoring
 * - API call tracking
 * - FPS tracking
 * - Alert generation
 */
@RunWith(AndroidJUnit4::class)
class PerformanceMonitorTest {
    
    private lateinit var context: Context
    private lateinit var performanceMonitor: PerformanceMonitor
    
    @Before
    fun setUp() {
        context = ApplicationProvider.getApplicationContext()
        performanceMonitor = PerformanceMonitor(context)
    }
    
    @After
    fun tearDown() {
        performanceMonitor.stopMonitoring()
    }
    
    @Test
    fun testPerformanceMonitorInitialization() {
        // Verify that performance monitor initializes correctly
        assertNotNull(performanceMonitor)
        assertFalse(performanceMonitor.isMonitoring.value)
    }
    
    @Test
    fun testStartStopMonitoring() = runBlocking {
        // Test starting monitoring
        performanceMonitor.startMonitoring()
        delay(100) // Allow coroutines to start
        assertTrue(performanceMonitor.isMonitoring.value)
        
        // Test stopping monitoring
        performanceMonitor.stopMonitoring()
        delay(100) // Allow coroutines to stop
        assertFalse(performanceMonitor.isMonitoring.value)
    }
    
    @Test
    fun testAppLaunchTracking() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Track app launch
        performanceMonitor.trackAppLaunchComplete()
        
        delay(100) // Allow processing
        
        val metrics = performanceMonitor.performanceMetrics.value
        assertNotNull(metrics.appLaunch)
        assertEquals(LaunchType.COLD, metrics.appLaunch?.type)
        assertTrue(metrics.appLaunch?.duration ?: 0 > 0)
    }
    
    @Test
    fun testNavigationTracking() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Track navigation
        performanceMonitor.trackNavigation("Home", "Profile")
        delay(50) // Simulate navigation time
        performanceMonitor.completeNavigation("Home", "Profile")
        
        delay(100) // Allow processing
        
        val navigationMetrics = performanceMonitor.navigationMetrics.value
        assertTrue(navigationMetrics.isNotEmpty())
        
        val metric = navigationMetrics.first()
        assertEquals("Home", metric.fromScreen)
        assertEquals("Profile", metric.toScreen)
        assertTrue(metric.duration >= 50)
    }
    
    @Test
    fun testApiCallTracking() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Track API call
        val callId = performanceMonitor.trackApiCall("/api/test", "GET")
        delay(100) // Simulate API delay
        performanceMonitor.completeApiCall(callId, true, 200)
        
        delay(100) // Allow processing
        
        val apiMetrics = performanceMonitor.apiMetrics.value
        assertTrue(apiMetrics.isNotEmpty())
        
        val metric = apiMetrics.first()
        assertEquals("/api/test", metric.endpoint)
        assertEquals("GET", metric.method)
        assertTrue(metric.success)
        assertEquals(200, metric.responseCode)
        assertTrue(metric.duration >= 100)
    }
    
    @Test
    fun testMemoryMetricsCollection() = runBlocking {
        performanceMonitor.startMonitoring()
        
        delay(200) // Allow memory monitoring to collect data
        
        val memoryMetrics = performanceMonitor.memoryMetrics.value
        assertTrue(memoryMetrics.currentUsageMB > 0)
        assertTrue(memoryMetrics.maxMemoryMB > 0)
        assertTrue(memoryMetrics.availableMemoryMB >= 0)
    }
    
    @Test
    fun testFpsTracking() {
        performanceMonitor.startMonitoring()
        
        // Simulate frame tracking
        repeat(60) {
            performanceMonitor.trackFrame()
        }
        
        val fps = performanceMonitor.getCurrentFPS()
        assertTrue(fps > 0)
        assertTrue(fps <= 60)
    }
    
    @Test
    fun testPerformanceSummary() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Generate some metrics
        performanceMonitor.trackAppLaunchComplete()
        
        val callId = performanceMonitor.trackApiCall("/api/test", "GET")
        delay(50)
        performanceMonitor.completeApiCall(callId, true, 200)
        
        performanceMonitor.trackNavigation("Home", "Profile")
        delay(25)
        performanceMonitor.completeNavigation("Home", "Profile")
        
        delay(200) // Allow processing
        
        val summary = performanceMonitor.getPerformanceSummary()
        assertNotNull(summary.appLaunchTime)
        assertNotNull(summary.averageApiResponseTime)
        assertNotNull(summary.averageNavigationTime)
        assertTrue(summary.currentMemoryUsage > 0)
    }
    
    @Test
    fun testHealthScoreCalculation() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Create a good performance scenario
        performanceMonitor.trackAppLaunchComplete() // Should be fast
        
        val callId = performanceMonitor.trackApiCall("/api/test", "GET")
        delay(50)
        performanceMonitor.completeApiCall(callId, true, 200)
        
        delay(200)
        
        val summary = performanceMonitor.getPerformanceSummary()
        val healthScore = summary.getOverallHealthScore()
        
        assertTrue(healthScore >= 0f)
        assertTrue(healthScore <= 100f)
    }
    
    @Test
    fun testNavigationAlertGeneration() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Simulate slow navigation (> 300ms)
        performanceMonitor.trackNavigation("Home", "SlowScreen")
        delay(400) // Exceed the 300ms target
        performanceMonitor.completeNavigation("Home", "SlowScreen")
        
        delay(200) // Allow processing
        
        val alerts = performanceMonitor.alerts.value
        assertTrue(alerts.isNotEmpty())
        
        val navigationAlert = alerts.find { it is PerformanceAlert.NavigationSlow }
        assertNotNull(navigationAlert)
        assertTrue((navigationAlert as PerformanceAlert.NavigationSlow).actualTime > 300)
    }
    
    @Test
    fun testAlertManagement() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Generate an alert
        performanceMonitor.trackNavigation("Home", "SlowScreen")
        delay(400)
        performanceMonitor.completeNavigation("Home", "SlowScreen")
        
        delay(200)
        
        val alertsBeforeClear = performanceMonitor.alerts.value
        assertTrue(alertsBeforeClear.isNotEmpty())
        
        // Clear all alerts
        performanceMonitor.clearAllAlerts()
        delay(100)
        
        val alertsAfterClear = performanceMonitor.alerts.value
        assertTrue(alertsAfterClear.isEmpty())
    }
    
    @Test
    fun testMemoryHealthCheck() {
        val healthyMemory = MemoryMetrics(
            currentUsageMB = 100,
            peakUsageMB = 120,
            isLowMemory = false
        )
        assertTrue(healthyMemory.isMemoryHealthy())
        
        val unhealthyMemory = MemoryMetrics(
            currentUsageMB = 200,
            peakUsageMB = 250,
            isLowMemory = false
        )
        assertFalse(unhealthyMemory.isMemoryHealthy())
        
        val lowMemory = MemoryMetrics(
            currentUsageMB = 100,
            peakUsageMB = 120,
            isLowMemory = true
        )
        assertFalse(lowMemory.isMemoryHealthy())
    }
    
    @Test
    fun testDeviceSuitabilityCheck() {
        val isSuitable = PerformanceMonitorUtils.isDeviceSuitableForMonitoring(context)
        // This will depend on the test device, but should not throw an exception
        assertTrue(isSuitable || !isSuitable) // Just ensure no exception
    }
    
    @Test
    fun testRecommendedIntervals() {
        val intervals = PerformanceMonitorUtils.getRecommendedMonitoringIntervals(context)
        assertTrue(intervals.first > 0) // Performance interval
        assertTrue(intervals.second > 0) // Memory interval
        assertTrue(intervals.second >= intervals.first) // Memory interval should be >= performance interval
    }
}

/**
 * Mock analytics service for testing
 */
class MockAnalyticsService : AnalyticsService {
    var lastReportedSummary: PerformanceSummary? = null
    var reportCount = 0
    
    override suspend fun reportPerformanceMetrics(summary: PerformanceSummary) {
        lastReportedSummary = summary
        reportCount++
    }
}

/**
 * Integration test for analytics reporting
 */
@RunWith(AndroidJUnit4::class)
class PerformanceMonitorAnalyticsTest {
    
    private lateinit var context: Context
    private lateinit var performanceMonitor: PerformanceMonitor
    private lateinit var mockAnalytics: MockAnalyticsService
    
    @Before
    fun setUp() {
        context = ApplicationProvider.getApplicationContext()
        performanceMonitor = PerformanceMonitor(context)
        mockAnalytics = MockAnalyticsService()
    }
    
    @After
    fun tearDown() {
        performanceMonitor.stopMonitoring()
    }
    
    @Test
    fun testAnalyticsReporting() = runBlocking {
        performanceMonitor.startMonitoring()
        
        // Generate some metrics
        performanceMonitor.trackAppLaunchComplete()
        delay(100)
        
        // Report to analytics
        performanceMonitor.reportToAnalytics(mockAnalytics)
        delay(100)
        
        assertEquals(1, mockAnalytics.reportCount)
        assertNotNull(mockAnalytics.lastReportedSummary)
        assertNotNull(mockAnalytics.lastReportedSummary?.appLaunchTime)
    }
}
