package com.tchat.services

import com.tchat.models.*
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.delay
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

/**
 * UI state manager for managing component states and synchronization
 */
@Singleton
class UIStateManager @Inject constructor(
    private val syncService: ComponentSyncService,
    private val persistenceService: UIStatePersistence,
    private val conflictResolver: StateConflictResolver
) {

    private val _componentStates = MutableStateFlow<Map<String, ComponentState>>(emptyMap())
    val componentStates: StateFlow<Map<String, ComponentState>> = _componentStates.asStateFlow()

    private val _isSyncing = MutableStateFlow(false)
    val isSyncing: StateFlow<Boolean> = _isSyncing.asStateFlow()

    private val _lastSyncTimestamp = MutableStateFlow<Long?>(null)
    val lastSyncTimestamp: StateFlow<Long?> = _lastSyncTimestamp.asStateFlow()

    private val _syncErrors = MutableStateFlow<List<UIStateError>>(emptyList())
    val syncErrors: StateFlow<List<UIStateError>> = _syncErrors.asStateFlow()

    private val stateMutex = Mutex()

    init {
        setupAutoSync()
        loadComponentStates()
    }

    /**
     * Get component state by instance ID
     */
    fun getComponentState(instanceId: String): ComponentState? {
        return _componentStates.value[instanceId]
    }

    /**
     * Update component state
     */
    suspend fun updateComponentState(
        instanceId: String,
        updates: Map<String, Any>,
        shouldSync: Boolean = true
    ) {
        stateMutex.withLock {
            val state = _componentStates.value[instanceId]
                ?: throw UIStateError.ComponentStateNotFound(instanceId)

            // Update state
            state.updateProperties(updates)
            _componentStates.value = _componentStates.value + (instanceId to state)

            // Persist changes
            persistenceService.saveComponentState(state)

            // Sync if requested
            if (shouldSync) {
                syncComponentState(instanceId)
            }
        }
    }

    /**
     * Create new component state
     */
    suspend fun createComponentState(
        state: ComponentState,
        shouldSync: Boolean = true
    ) {
        stateMutex.withLock {
            // Check for existing state
            if (_componentStates.value.containsKey(state.instanceId)) {
                throw UIStateError.ComponentStateAlreadyExists(state.instanceId)
            }

            // Store state
            _componentStates.value = _componentStates.value + (state.instanceId to state)

            // Persist
            persistenceService.saveComponentState(state)

            // Sync if requested
            if (shouldSync) {
                syncComponentState(state.instanceId)
            }
        }
    }

    /**
     * Remove component state
     */
    suspend fun removeComponentState(
        instanceId: String,
        shouldSync: Boolean = true
    ) {
        stateMutex.withLock {
            val state = _componentStates.value[instanceId]
                ?: throw UIStateError.ComponentStateNotFound(instanceId)

            // Remove from memory
            _componentStates.value = _componentStates.value - instanceId

            // Remove from persistence
            persistenceService.removeComponentState(instanceId)

            // Sync removal if requested
            if (shouldSync) {
                // TODO: Implement state removal sync
            }
        }
    }

    /**
     * Merge component state with external state
     */
    suspend fun mergeComponentState(
        instanceId: String,
        externalState: Map<String, Any>,
        strategy: MergeStrategy = MergeStrategy.OVERWRITE
    ) {
        stateMutex.withLock {
            val state = _componentStates.value[instanceId]
                ?: throw UIStateError.ComponentStateNotFound(instanceId)

            // Merge states
            state.mergeState(externalState, strategy)
            _componentStates.value = _componentStates.value + (instanceId to state)

            // Persist changes
            persistenceService.saveComponentState(state)
        }
    }

    /**
     * Sync specific component state
     */
    suspend fun syncComponentState(instanceId: String) {
        val state = _componentStates.value[instanceId]
            ?: throw UIStateError.ComponentStateNotFound(instanceId)

        _isSyncing.value = true

        try {
            val syncRequest = state.createSyncRequest()
            val response = syncService.syncComponentState(syncRequest)

            if (response.success) {
                val updatedState = state.applySyncResponse(response)
                _componentStates.value = _componentStates.value + (instanceId to updatedState)

                // Update persistence
                persistenceService.saveComponentState(updatedState)

                _lastSyncTimestamp.value = System.currentTimeMillis()
            }

        } catch (e: Exception) {
            val uiError = UIStateError.SyncFailed(instanceId, e)
            _syncErrors.value = _syncErrors.value + uiError
            throw uiError
        } finally {
            _isSyncing.value = false
        }
    }

    /**
     * Sync all component states
     */
    suspend fun syncAllComponentStates() {
        val states = _componentStates.value.values.toList()
        if (states.isEmpty()) return

        _isSyncing.value = true

        try {
            val syncRequest = ComponentStateSyncRequest(
                userId = getCurrentUserId(),
                sessionId = getCurrentSessionId(),
                platform = "android",
                componentStates = states,
                timestamp = System.currentTimeMillis(),
                syncVersion = 1
            )

            val response = syncService.syncComponentState(syncRequest)

            if (response.success) {
                // Handle conflicts if any
                if (response.conflictsResolved.isNotEmpty()) {
                    handleSyncConflicts(response.conflictsResolved)
                }

                _lastSyncTimestamp.value = System.currentTimeMillis()
            }

        } catch (e: Exception) {
            val uiError = UIStateError.SyncAllFailed(e)
            _syncErrors.value = _syncErrors.value + uiError
            throw uiError
        } finally {
            _isSyncing.value = false
        }
    }

    /**
     * Get states by component type
     */
    fun getComponentStates(componentId: String): List<ComponentState> {
        return _componentStates.value.values.filter { it.componentId == componentId }
    }

    /**
     * Get all synchronized states
     */
    fun getSynchronizedStates(): List<ComponentState> {
        return _componentStates.value.values.filter { it.isSynchronized }
    }

    /**
     * Get unsynchronized states
     */
    fun getUnsynchronizedStates(): List<ComponentState> {
        return _componentStates.value.values.filter { !it.isSynchronized }
    }

    /**
     * Clear all errors
     */
    suspend fun clearErrors() {
        _syncErrors.value = emptyList()
    }

    /**
     * Reset all component states
     */
    suspend fun resetAllStates() {
        stateMutex.withLock {
            _componentStates.value = emptyMap()
            persistenceService.clearAllStates()
            _lastSyncTimestamp.value = null
            _syncErrors.value = emptyList()
        }
    }

    // MARK: - Private Methods

    private fun setupAutoSync() {
        // Auto-sync every 30 seconds
        kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.IO).launch {
            while (true) {
                delay(30_000) // 30 seconds
                try {
                    syncUnsynchronizedStates()
                } catch (e: Exception) {
                    // Log error but continue
                }
            }
        }
    }

    private suspend fun syncUnsynchronizedStates() {
        val unsyncedStates = getUnsynchronizedStates()

        for (state in unsyncedStates) {
            try {
                syncComponentState(state.instanceId)
            } catch (e: Exception) {
                // Log error but continue with other states
            }
        }
    }

    private fun loadComponentStates() {
        kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.IO).launch {
            try {
                val loadedStates = persistenceService.loadAllComponentStates()

                val statesMap = loadedStates.associateBy { it.instanceId }
                _componentStates.value = statesMap

            } catch (e: Exception) {
                // Log error but don't fail initialization
                println("Failed to load component states: ${e.message}")
            }
        }
    }

    private suspend fun handleSyncConflicts(conflictIds: List<String>) {
        for (conflictId in conflictIds) {
            val localState = _componentStates.value[conflictId] ?: continue

            // TODO: Fetch remote state and resolve conflict
            // For now, we'll keep the local state
        }
    }

    private fun getCurrentUserId(): String {
        // TODO: Get from authentication service
        return "current_user_id"
    }

    private fun getCurrentSessionId(): String {
        // TODO: Get from session service
        return UUID.randomUUID().toString()
    }
}

// MARK: - Supporting Services

/**
 * Component sync service
 */
@Singleton
class ComponentSyncService @Inject constructor() {

    suspend fun syncComponentState(request: ComponentStateSyncRequest): ComponentStateSyncResponse {
        // TODO: Implement actual sync with backend
        return ComponentStateSyncResponse(
            success = true,
            syncVersion = request.syncVersion + 1,
            conflictsResolved = emptyList(),
            timestamp = System.currentTimeMillis()
        )
    }
}

/**
 * UI state persistence service
 */
@Singleton
class UIStatePersistence @Inject constructor() {

    suspend fun saveComponentState(state: ComponentState) {
        // TODO: Implement persistence (SharedPreferences, Room, etc.)
    }

    suspend fun loadComponentState(instanceId: String): ComponentState? {
        // TODO: Implement loading
        return null
    }

    suspend fun loadAllComponentStates(): List<ComponentState> {
        // TODO: Implement loading all states
        return emptyList()
    }

    suspend fun removeComponentState(instanceId: String) {
        // TODO: Implement removal
    }

    suspend fun clearAllStates() {
        // TODO: Implement clearing all states
    }
}

/**
 * State conflict resolver
 */
@Singleton
class StateConflictResolver @Inject constructor() {

    fun resolveConflict(
        local: ComponentState,
        remote: ComponentState,
        strategy: ConflictResolutionStrategy = ConflictResolutionStrategy.NEWEST_WINS
    ): ComponentState {
        return when (strategy) {
            ConflictResolutionStrategy.NEWEST_WINS -> {
                if (remote.timestamp > local.timestamp) remote else local
            }
            ConflictResolutionStrategy.HIGHEST_VERSION_WINS -> {
                if (remote.version > local.version) remote else local
            }
            ConflictResolutionStrategy.MERGE -> {
                local.resolveConflictWith(remote, strategy)
            }
            ConflictResolutionStrategy.MANUAL -> {
                // Manual resolution required - return local for now
                local
            }
        }
    }
}

// MARK: - Error Types

sealed class UIStateError : Exception() {
    class ComponentStateNotFound(val id: String) : UIStateError()
    class ComponentStateAlreadyExists(val id: String) : UIStateError()
    class SyncFailed(val id: String, val error: Throwable) : UIStateError()
    class SyncAllFailed(val error: Throwable) : UIStateError()
    class PersistenceFailed(val error: Throwable) : UIStateError()
    class ConflictResolutionFailed(val id: String) : UIStateError()

    override val message: String?
        get() = when (this) {
            is ComponentStateNotFound -> "Component state not found: $id"
            is ComponentStateAlreadyExists -> "Component state already exists: $id"
            is SyncFailed -> "Sync failed for component $id: ${error.message}"
            is SyncAllFailed -> "Sync all failed: ${error.message}"
            is PersistenceFailed -> "Persistence failed: ${error.message}"
            is ConflictResolutionFailed -> "Conflict resolution failed for component: $id"
        }
}