package com.tchat.services

import com.tchat.models.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import java.io.IOException
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Real implementation of Platform Adapter API Client for Android
 */
@Singleton
class PlatformAdapterAPIClient @Inject constructor(
    private val httpClient: OkHttpClient = createDefaultHttpClient(),
    private val authenticationProvider: AuthenticationProvider = AuthenticationProvider(),
    private val baseURL: String = "https://api.tchat.app"
) {

    private val json = Json {
        ignoreUnknownKeys = true
        encodeDefaults = true
    }

    // MARK: - Platform Capabilities API

    /**
     * GET /platform/capabilities
     */
    suspend fun getPlatformCapabilities(platform: String, version: String): PlatformCapabilitiesAPIResponse = withContext(Dispatchers.IO) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(baseURL.removePrefix("https://"))
            .addPathSegments("platform/capabilities")
            .addQueryParameter("platform", platform)
            .addQueryParameter("version", version)
            .build()

        val request = Request.Builder()
            .url(url)
            .get()
            .addHeader("Accept", "application/json")
            .apply {
                authenticationProvider.getAccessToken()?.let { token ->
                    addHeader("Authorization", "Bearer $token")
                }
            }
            .build()

        try {
            val response = httpClient.newCall(request).execute()

            when (response.code) {
                200 -> {
                    val responseBody = response.body?.string()
                        ?: throw PlatformAdapterAPIException("EMPTY_RESPONSE", "Response body is empty")
                    json.decodeFromString<PlatformCapabilitiesAPIResponse>(responseBody)
                }
                400 -> throw PlatformAdapterAPIException("INVALID_PLATFORM", "Invalid platform or version")
                401 -> throw PlatformAdapterAPIException("UNAUTHORIZED", "Authentication required")
                404 -> throw PlatformAdapterAPIException("PLATFORM_NOT_SUPPORTED", "Platform not supported")
                else -> throw PlatformAdapterAPIException("HTTP_ERROR", "HTTP ${response.code}")
            }

        } catch (e: PlatformAdapterAPIException) {
            throw e
        } catch (e: IOException) {
            throw PlatformAdapterAPIException("NETWORK_ERROR", e.message ?: "Network error occurred")
        } catch (e: Exception) {
            throw PlatformAdapterAPIException("UNKNOWN_ERROR", e.message ?: "Unknown error occurred")
        }
    }

    // MARK: - Gesture Handling API

    /**
     * POST /platform/gestures/handle
     */
    suspend fun handleGesture(request: GestureHandlingAPIRequest): GestureHandlingAPIResponse = withContext(Dispatchers.IO) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(baseURL.removePrefix("https://"))
            .addPathSegments("platform/gestures/handle")
            .build()

        val requestBody = json.encodeToString(request)
            .toRequestBody("application/json".toMediaType())

        val httpRequest = Request.Builder()
            .url(url)
            .post(requestBody)
            .addHeader("Content-Type", "application/json")
            .addHeader("Accept", "application/json")
            .apply {
                authenticationProvider.getAccessToken()?.let { token ->
                    addHeader("Authorization", "Bearer $token")
                }
            }
            .build()

        try {
            val response = httpClient.newCall(httpRequest).execute()

            when (response.code) {
                200 -> {
                    val responseBody = response.body?.string()
                        ?: throw PlatformAdapterAPIException("EMPTY_RESPONSE", "Response body is empty")
                    json.decodeFromString<GestureHandlingAPIResponse>(responseBody)
                }
                400 -> throw PlatformAdapterAPIException("INVALID_GESTURE", "Invalid gesture request")
                401 -> throw PlatformAdapterAPIException("UNAUTHORIZED", "Authentication required")
                422 -> throw PlatformAdapterAPIException("GESTURE_NOT_SUPPORTED", "Gesture not supported on platform")
                else -> throw PlatformAdapterAPIException("HTTP_ERROR", "HTTP ${response.code}")
            }

        } catch (e: PlatformAdapterAPIException) {
            throw e
        } catch (e: IOException) {
            throw PlatformAdapterAPIException("NETWORK_ERROR", e.message ?: "Network error occurred")
        } catch (e: Exception) {
            throw PlatformAdapterAPIException("UNKNOWN_ERROR", e.message ?: "Unknown error occurred")
        }
    }

    // MARK: - Animation Execution API

    /**
     * POST /platform/animations/execute
     */
    suspend fun executeAnimation(request: AnimationExecutionAPIRequest): AnimationExecutionAPIResponse = withContext(Dispatchers.IO) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(baseURL.removePrefix("https://"))
            .addPathSegments("platform/animations/execute")
            .build()

        val requestBody = json.encodeToString(request)
            .toRequestBody("application/json".toMediaType())

        val httpRequest = Request.Builder()
            .url(url)
            .post(requestBody)
            .addHeader("Content-Type", "application/json")
            .addHeader("Accept", "application/json")
            .apply {
                authenticationProvider.getAccessToken()?.let { token ->
                    addHeader("Authorization", "Bearer $token")
                }
            }
            .build()

        try {
            val response = httpClient.newCall(httpRequest).execute()

            when (response.code) {
                200 -> {
                    val responseBody = response.body?.string()
                        ?: throw PlatformAdapterAPIException("EMPTY_RESPONSE", "Response body is empty")
                    json.decodeFromString<AnimationExecutionAPIResponse>(responseBody)
                }
                400 -> throw PlatformAdapterAPIException("INVALID_ANIMATION", "Invalid animation request")
                401 -> throw PlatformAdapterAPIException("UNAUTHORIZED", "Authentication required")
                422 -> throw PlatformAdapterAPIException("ANIMATION_NOT_SUPPORTED", "Animation not supported on platform")
                else -> throw PlatformAdapterAPIException("HTTP_ERROR", "HTTP ${response.code}")
            }

        } catch (e: PlatformAdapterAPIException) {
            throw e
        } catch (e: IOException) {
            throw PlatformAdapterAPIException("NETWORK_ERROR", e.message ?: "Network error occurred")
        } catch (e: Exception) {
            throw PlatformAdapterAPIException("UNKNOWN_ERROR", e.message ?: "Unknown error occurred")
        }
    }

    // MARK: - UI Conventions API

    /**
     * GET /platform/ui-conventions
     */
    suspend fun getUIConventions(platform: String): UIConventionsAPIResponse = withContext(Dispatchers.IO) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(baseURL.removePrefix("https://"))
            .addPathSegments("platform/ui-conventions")
            .addQueryParameter("platform", platform)
            .build()

        val request = Request.Builder()
            .url(url)
            .get()
            .addHeader("Accept", "application/json")
            .apply {
                authenticationProvider.getAccessToken()?.let { token ->
                    addHeader("Authorization", "Bearer $token")
                }
            }
            .build()

        try {
            val response = httpClient.newCall(request).execute()

            when (response.code) {
                200 -> {
                    val responseBody = response.body?.string()
                        ?: throw PlatformAdapterAPIException("EMPTY_RESPONSE", "Response body is empty")
                    json.decodeFromString<UIConventionsAPIResponse>(responseBody)
                }
                400 -> throw PlatformAdapterAPIException("INVALID_PLATFORM", "Invalid platform specified")
                401 -> throw PlatformAdapterAPIException("UNAUTHORIZED", "Authentication required")
                404 -> throw PlatformAdapterAPIException("CONVENTIONS_NOT_FOUND", "UI conventions not found for platform")
                else -> throw PlatformAdapterAPIException("HTTP_ERROR", "HTTP ${response.code}")
            }

        } catch (e: PlatformAdapterAPIException) {
            throw e
        } catch (e: IOException) {
            throw PlatformAdapterAPIException("NETWORK_ERROR", e.message ?: "Network error occurred")
        } catch (e: Exception) {
            throw PlatformAdapterAPIException("UNKNOWN_ERROR", e.message ?: "Unknown error occurred")
        }
    }

    // MARK: - Device Features API

    /**
     * POST /platform/device/features
     */
    suspend fun reportDeviceFeatures(request: DeviceFeaturesReportRequest): DeviceFeaturesReportResponse = withContext(Dispatchers.IO) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(baseURL.removePrefix("https://"))
            .addPathSegments("platform/device/features")
            .build()

        val requestBody = json.encodeToString(request)
            .toRequestBody("application/json".toMediaType())

        val httpRequest = Request.Builder()
            .url(url)
            .post(requestBody)
            .addHeader("Content-Type", "application/json")
            .addHeader("Accept", "application/json")
            .apply {
                authenticationProvider.getAccessToken()?.let { token ->
                    addHeader("Authorization", "Bearer $token")
                }
            }
            .build()

        try {
            val response = httpClient.newCall(httpRequest).execute()

            when (response.code) {
                200 -> {
                    val responseBody = response.body?.string()
                        ?: throw PlatformAdapterAPIException("EMPTY_RESPONSE", "Response body is empty")
                    json.decodeFromString<DeviceFeaturesReportResponse>(responseBody)
                }
                400 -> throw PlatformAdapterAPIException("INVALID_DEVICE_DATA", "Invalid device features data")
                401 -> throw PlatformAdapterAPIException("UNAUTHORIZED", "Authentication required")
                else -> throw PlatformAdapterAPIException("HTTP_ERROR", "HTTP ${response.code}")
            }

        } catch (e: PlatformAdapterAPIException) {
            throw e
        } catch (e: IOException) {
            throw PlatformAdapterAPIException("NETWORK_ERROR", e.message ?: "Network error occurred")
        } catch (e: Exception) {
            throw PlatformAdapterAPIException("UNKNOWN_ERROR", e.message ?: "Unknown error occurred")
        }
    }

    // MARK: - Performance Metrics API

    /**
     * POST /platform/performance/metrics
     */
    suspend fun reportPerformanceMetrics(request: PerformanceMetricsRequest): PerformanceMetricsResponse = withContext(Dispatchers.IO) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(baseURL.removePrefix("https://"))
            .addPathSegments("platform/performance/metrics")
            .build()

        val requestBody = json.encodeToString(request)
            .toRequestBody("application/json".toMediaType())

        val httpRequest = Request.Builder()
            .url(url)
            .post(requestBody)
            .addHeader("Content-Type", "application/json")
            .addHeader("Accept", "application/json")
            .apply {
                authenticationProvider.getAccessToken()?.let { token ->
                    addHeader("Authorization", "Bearer $token")
                }
            }
            .build()

        try {
            val response = httpClient.newCall(httpRequest).execute()

            when (response.code) {
                200, 202 -> { // 200 = processed, 202 = accepted for async processing
                    val responseBody = response.body?.string()
                        ?: throw PlatformAdapterAPIException("EMPTY_RESPONSE", "Response body is empty")
                    json.decodeFromString<PerformanceMetricsResponse>(responseBody)
                }
                400 -> throw PlatformAdapterAPIException("INVALID_METRICS", "Invalid performance metrics data")
                401 -> throw PlatformAdapterAPIException("UNAUTHORIZED", "Authentication required")
                413 -> throw PlatformAdapterAPIException("METRICS_TOO_LARGE", "Performance metrics payload too large")
                else -> throw PlatformAdapterAPIException("HTTP_ERROR", "HTTP ${response.code}")
            }

        } catch (e: PlatformAdapterAPIException) {
            throw e
        } catch (e: IOException) {
            throw PlatformAdapterAPIException("NETWORK_ERROR", e.message ?: "Network error occurred")
        } catch (e: Exception) {
            throw PlatformAdapterAPIException("UNKNOWN_ERROR", e.message ?: "Unknown error occurred")
        }
    }

    companion object {
        private fun createDefaultHttpClient(): OkHttpClient {
            return OkHttpClient.Builder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(30, TimeUnit.SECONDS)
                .build()
        }
    }
}

// MARK: - Request Models

@Serializable
data class GestureHandlingAPIRequest(
    val gestureType: String,
    val direction: String,
    val velocity: Double,
    val position: GesturePosition,
    val platform: String,
    val componentId: String,
    val metadata: Map<String, kotlinx.serialization.json.JsonElement>,
    val timestamp: Long, // Unix timestamp
    val sessionId: String
)

@Serializable
data class AnimationExecutionAPIRequest(
    val animationType: String,
    val duration: Double,
    val easing: String,
    val properties: Map<String, kotlinx.serialization.json.JsonElement>,
    val platform: String,
    val componentId: String,
    val timestamp: Long, // Unix timestamp
    val sessionId: String
)

@Serializable
data class DeviceFeaturesReportRequest(
    val platform: String,
    val platformVersion: String,
    val deviceModel: String,
    val features: Map<String, Boolean>,
    val capabilities: Map<String, kotlinx.serialization.json.JsonElement>,
    val limitations: List<String>,
    val userId: String,
    val sessionId: String,
    val timestamp: Long // Unix timestamp
)

@Serializable
data class PerformanceMetricsRequest(
    val platform: String,
    val metrics: PerformanceMetrics,
    val userId: String,
    val sessionId: String,
    val timestamp: Long // Unix timestamp
)

@Serializable
data class PerformanceMetrics(
    val appLaunchTime: Double,
    val navigationTime: Double,
    val renderTime: Double,
    val memoryUsage: Double,
    val cpuUsage: Double,
    val networkLatency: Double,
    val frameRate: Double,
    val customMetrics: Map<String, Double>
)

// MARK: - Response Models

@Serializable
data class PlatformCapabilitiesAPIResponse(
    val platform: String,
    val version: String,
    val capabilities: List<PlatformCapability>,
    val limitations: List<String>,
    val supportedGestures: List<String>,
    val supportedAnimations: List<String>,
    val performanceTargets: PerformanceTargets
)

@Serializable
data class PerformanceTargets(
    val maxAppLaunchTime: Double,
    val maxNavigationTime: Double,
    val minFrameRate: Double,
    val maxMemoryUsage: Double
)

@Serializable
data class GestureHandlingAPIResponse(
    val handled: Boolean,
    val action: String?,
    val gestureType: String,
    val timestamp: Long, // Unix timestamp
    val preventDefaultBehavior: Boolean,
    val platformOptimizations: Map<String, kotlinx.serialization.json.JsonElement>
)

@Serializable
data class AnimationExecutionAPIResponse(
    val started: Boolean,
    val animationType: String,
    val duration: Double,
    val animationId: String,
    val timestamp: Long, // Unix timestamp
    val platformOptimizations: Map<String, kotlinx.serialization.json.JsonElement>
)

@Serializable
data class UIConventionsAPIResponse(
    val platform: String,
    val designSystem: DesignSystem,
    val navigationPatterns: Map<String, String>,
    val gestureConventions: Map<String, kotlinx.serialization.json.JsonElement>,
    val animationSpecs: Map<String, kotlinx.serialization.json.JsonElement>,
    val accessibilityGuidelines: Map<String, String>
)

@Serializable
data class DeviceFeaturesReportResponse(
    val acknowledged: Boolean,
    val optimizations: Map<String, kotlinx.serialization.json.JsonElement>,
    val recommendations: List<String>,
    val timestamp: Long // Unix timestamp
)

@Serializable
data class PerformanceMetricsResponse(
    val received: Boolean,
    val processed: Boolean,
    val insights: List<String>,
    val optimizationSuggestions: List<String>,
    val timestamp: Long // Unix timestamp
)

// MARK: - Error Types

class PlatformAdapterAPIException(
    val code: String,
    override val message: String
) : Exception(message) {
    override fun toString(): String = "$code: $message"
}

// MARK: - API Client Factory

/**
 * Factory for creating Platform Adapter API clients with proper configuration
 */
@Singleton
class PlatformAdapterAPIClientFactory @Inject constructor() {

    fun create(environment: Environment = Environment.DEVELOPMENT): PlatformAdapterAPIClient {
        val baseURL = when (environment) {
            Environment.DEVELOPMENT -> "https://dev-api.tchat.app"
            Environment.STAGING -> "https://staging-api.tchat.app"
            Environment.PRODUCTION -> "https://api.tchat.app"
        }

        return PlatformAdapterAPIClient(
            httpClient = PlatformAdapterAPIClient.createDefaultHttpClient(),
            authenticationProvider = AuthenticationProvider(),
            baseURL = baseURL
        )
    }
}